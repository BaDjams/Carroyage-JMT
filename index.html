<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Générateur de carroyage CADO V6.0</title>
  <style>
    /* Style CSS */
    body {
      font-family: Arial, sans-serif;
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
      box-sizing: border-box;
    }
    h1 {
      font-size: 1.5em;
      text-align: center;
    }
    label {
      display: block;
      margin-bottom: 5px;
      font-size: 0.9em;
    }
    input, select, button, .slider-container {
      width: 100%;
      margin-bottom: 15px;
      padding: 10px;
      font-size: 16px;
      box-sizing: border-box;
    }
    input[type="color"], input[type="range"] {
      padding: 0;
      height: 40px;
    }
    button {
      background-color: #4CAF50;
      color: white;
      border: none;
      cursor: pointer;
      padding: 10px;
    }
    button:hover {
      background-color: #45a049;
    }
    .help-button {
      width: 30px;
      height: 30px;
      margin-left: 10px;
      border-radius: 50%;
      background-color: #4CAF50;
      color: white;
      font-size: 18px;
      font-weight: bold;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      text-decoration: none;
    }
    
   .coord-container {
        display: flex;
        align-items: center;
      }
      
      #coordinates {
        flex: 7; /* 70% de la largeur */
        padding: 8px;
      }
      
      #convertButton {
        flex: 3; /* 30% de la largeur */
        margin-left: 10px;
        padding: 8px 12px;
        background-color: grey; /* Par défaut désactivé */
        color: white;
        border: none;
        cursor: not-allowed; /* Désactivé par défaut */
      }
      
      #convertButton.active {
        background-color: #4CAF50; /* Vert quand actif */
        cursor: pointer;
      }
      
      #convertButton:hover.active {
        background-color: #45a049;
      }



    .help-button:hover {
      background-color: #45a049;
    }

    .button-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      margin-bottom: 15px;
    }
    .button-container button {
      width: auto;
      margin: 5px;
    }
    .slider-value {
      text-align: center;
      margin-top: -10px;
      margin-bottom: 10px;
      font-size: 0.9em;
    }
    @media (max-width: 600px) {
      body {
        padding: 10px;
      }
      h1 {
        font-size: 1.2em;
      }
      input, select, button, .slider-container {
        font-size: 14px;
      }
      .button-container button {
        font-size: 14px;
      }
    }
  </style>
  <!-- Inclure jszip.js localement pour un fonctionnement hors ligne -->
  <script src="jszip.js"></script>
    <!-- Inclure le fichier images.js AVANT votre script principal -->
  <script src="images.js"></script>
  <script>
   // Conversion de la liste en un dictionnaire pour un accès facile
    const imageBase64Dict = {};
    imageBase64Data.forEach(item => {
      imageBase64Dict[item.name] = item.base64;
    });
    
    const METERS_PER_DEGREE_LAT = 111320;

    function toggleCustomGridOptions() {
      const gridOption = document.getElementById("gridOption").value;
      const defaultGridOptions = document.getElementById("defaultGridOptions");
      const customGridOptions = document.getElementById("customGridOptions");
      const customGridHint = document.getElementById("customGridHint");
    
      if (gridOption === "custom") {
        defaultGridOptions.style.display = "none";
        customGridOptions.style.display = "block";
        customGridHint.style.display = "block";
      } else {
        defaultGridOptions.style.display = "block";
        customGridOptions.style.display = "none";
        customGridHint.style.display = "none";
      }
    }

    function convertCoordinates() {
        const inputField = document.getElementById("coordinates");
        let inputValue = inputField.value.trim();
      
        if (isDecimal(inputValue)) {
          inputField.value = convertDecimalToDMS(inputValue);
        } else if (isDMS(inputValue)) {
          inputField.value = convertDMSToDecimal(inputValue);
        } else {
          alert("Format de coordonnées invalide. Veuillez entrer des coordonnées valides.");
        }
      }
      
     function isDecimal(value) {
        return /^-?\d+(\.\d+)?,\s*-?\d+(\.\d+)?$/.test(value);
      }

      
      function isDMS(value) {
        return /^(\d{1,3})°\s*(\d{1,2})'\s*(\d{1,2}(?:\.\d+)?)(?:''|\"?)?\s*([NSEW]),?\s*(\d{1,3})°\s*(\d{1,2})'\s*(\d{1,2}(?:\.\d+)?)(?:''|\"?)?\s*([NSEW])$/i.test(value);
      }


      
      function convertDecimalToDMS(decimal) {
        let coords = decimal.split(',').map(coord => parseFloat(coord.trim()));
        if (coords.length !== 2 || isNaN(coords[0]) || isNaN(coords[1])) return "Format invalide.";
      
        return `${toDMS(coords[0], 'NS')}, ${toDMS(coords[1], 'EW')}`;
      }


      
     function convertDMSToDecimal(dms) {
          // Étape 1 : Séparer les coordonnées en latitude et longitude
          const regex = /^([\d°'"\sNSEW.,-]+)[, ]+([\d°'"\sNSEW.,-]+)$/i;
          let match = dms.match(regex);
          
          if (!match) {
              alert("Format invalide. Veuillez entrer des coordonnées en DMS correctes.");
              return;
          }
      
          let latDMS = match[1].trim();
          let lonDMS = match[2].trim();
      
          // Étape 2 : Supprimer toutes les virgules et espaces superflues
          latDMS = latDMS.replace(/[, ]+/g, '');
          lonDMS = lonDMS.replace(/[, ]+/g, '');
      
          // Étape 3 : Séparer chaque bloc en degrés, minutes, secondes
          function parseDMS(dmsStr) {
              const dmsRegex = /^(\d{1,3})°(\d{1,2})'(\d{1,2}(?:\.\d+)?)?"?([NSEW])$/i;
              let dmsMatch = dmsStr.match(dmsRegex);
              if (!dmsMatch) return null;
      
              let degrees = parseFloat(dmsMatch[1]);
              let minutes = parseFloat(dmsMatch[2]) / 60;
              let seconds = parseFloat(dmsMatch[3]) / 3600;
              let direction = dmsMatch[4].toUpperCase();
      
              // Étape 4 : Conversion en degrés décimaux
              let decimal = degrees + minutes + seconds;
      
              // Étape 5 : Appliquer le signe négatif si S ou W
              if (direction === "S" || direction === "W") decimal *= -1;
      
              return decimal.toFixed(6);
          }
      
          let latDecimal = parseDMS(latDMS);
          let lonDecimal = parseDMS(lonDMS);
      
          if (latDecimal === null || lonDecimal === null) {
              alert("Erreur de conversion. Vérifiez le format DMS.");
              return;
          }
      
          // **Mise à jour du champ input avec la nouvelle valeur**
          document.getElementById("coordinates").value = `${latDecimal}, ${lonDecimal}`;
      
          // **Réactiver le bouton Convertir et mettre à jour le texte**
          validateInput();
      }





      
      function toDMS(deg, type) {
          const absolute = Math.abs(deg);
          const degrees = Math.floor(absolute);
          const minutesNotTruncated = (absolute - degrees) * 60;
          const minutes = Math.floor(minutesNotTruncated);
          const seconds = ((minutesNotTruncated - minutes) * 60).toFixed(2);
          
          // Formater les valeurs en assurant 2 chiffres minimum pour minutes/secondes
          const formattedMinutes = minutes.toString().padStart(2, '0');
          const formattedSeconds = seconds.toString().padStart(5, '0');
        
          const direction = deg >= 0 ? (type === "NS" ? "N" : "E") : (type === "NS" ? "S" : "W");
        
          return `${degrees}° ${formattedMinutes}' ${formattedSeconds}" ${direction}`;
        }

      function getRequiredImages(points) {
        const requiredImages = {};
      
        // Parcourir les noms des points nécessaires
        points.forEach(point => {
          if (imageBase64Dict[point]) {
            requiredImages[point] = imageBase64Dict[point];
          }
        });
      
        return requiredImages;
      }
    
    function updateSliderValue(sliderId, valueId, unit = '') {
      const slider = document.getElementById(sliderId);
      const valueElement = document.getElementById(valueId);
      valueElement.textContent = slider.value + unit;
    }

    function generateKML(type) {
        const inputField = document.getElementById("coordinates");
        
        // Convertir en degrés décimaux avant génération
        if (isDMS(inputField.value)) {
          inputField.value = convertDMSToDecimal(inputField.value);
        }
      
        const kmlContent = createKMLContent(type, false);
        if (!kmlContent) return;
      
        const filename = getKMLFilename(type);
        downloadFile(kmlContent, filename, 'text/plain');
      }


        // Fonction pour extraire les noms des points depuis le contenu KML
    function extractPointNames(kmlContent) {
      const pointNames = [];
      const regex = /<name>(.*?)<\/name>/g;
      let match;
    
      while ((match = regex.exec(kmlContent)) !== null) {
        pointNames.push(match[1]);
      }
    
      return pointNames;
    }


    async function generateKMZ(type) {
        const inputField = document.getElementById("coordinates");
      
        // Convertir en degrés décimaux avant génération
        if (isDMS(inputField.value)) {
          inputField.value = convertDMSToDecimal(inputField.value);
        }
      const kmlDocContent = createKMLContent(type, true);
      if (!kmlDocContent) return;

      // Créer un fichier KMZ en mémoire sans utiliser de fichier ZIP externe
      const zip = new JSZip();

      zip.file("doc.kml", kmlDocContent);

      // Générer les icônes à partir des données base64
       // Extraire les noms des points nécessaires à partir du contenu KML
      const points = extractPointNames(kmlDocContent);
      
      // Récupérer uniquement les images nécessaires
      const requiredImages = getRequiredImages(points);
      
      // Ajouter uniquement les images nécessaires dans le dossier "icons" du KMZ
      const iconsFolder = zip.folder("icons");
      for (const [name, base64] of Object.entries(requiredImages)) {
        iconsFolder.file(`${name}.png`, base64, { base64: true });
      }


      const content = await zip.generateAsync({ type: "blob" });
      const filename = getKMLFilename(type).replace('.kml', '.kmz');
      downloadFile(content, filename, 'application/vnd.google-earth.kmz');
    }

    function createKMLContent(type, isKMZ) {
      const coordinatesInput = document.getElementById("coordinates").value;
      const lengthInput = document.getElementById("length").value;
      const colorInput = document.getElementById("color").value;
      const transparencyInput = document.getElementById("transparency").value;
      const gridOption = document.getElementById("gridOption").value;
      const iconSize = document.getElementById("iconSize").value;
      const deviationInput = document.getElementById("deviation").value;

      if (!validateInputs(coordinatesInput, lengthInput)) return null;

      const [latitude, longitude] = coordinatesInput.split(',').map(coord => parseFloat(coord.trim()));
      const length = parseFloat(lengthInput);
      const referencePoint = document.getElementById("referencePoint").value;

      const transparencyHex = Math.floor((100 - transparencyInput) * 2.55).toString(16).padStart(2, '0');
      const rgbHex = colorInput.slice(1);
      const kmlColor = transparencyHex + rgbHex.slice(4, 6) + rgbHex.slice(2, 4) + rgbHex.slice(0, 2);

      const rowRange = getGridRowRange();
      const colRange = getGridColRange();

      if (!rowRange || !colRange) return null; // Si validation échoue

      let { rowStart, rowEnd } = rowRange;
      let { colStart, colEnd } = colRange;

      const { startingLat, startingLon, rowIndices, colIndices } = calculateStartingPoint(latitude, longitude, length, referencePoint, rowStart, rowEnd, colStart, colEnd);

      let kmlContent = getKMLHeader(kmlColor, isKMZ, iconSize, transparencyHex, rowStart, rowEnd, colStart, colEnd);

      for (let rowIndex of rowIndices) {
        if (rowIndex === 0) continue; // Sauter le zéro pour les lignes
        for (let colIndex of colIndices) {
          if (colIndex === 0) continue; // Sauter le zéro pour les colonnes

          const colLabel = getColumnLabel(colIndex);
          const rowLabel = getRowLabel(rowIndex);

          const coords = getGridCellCoordinates(rowIndex, colIndex, startingLat, startingLon, length, rowIndices, colIndices, referencePoint);

          // Rotation des coins de la grille
          const gridCoords = rotateCoordinates(coords.lat, coords.lon, latitude, longitude, deviationInput);

          // Calcul du centre pour les points avec rotation
          const centerLatOffset = (length / (2 * METERS_PER_DEGREE_LAT)) * ((referencePoint === "topLeft") ? -1 : 1);
          const centerLat = coords.lat + centerLatOffset;
          const centerLon = coords.lon + (length / (2 * (METERS_PER_DEGREE_LAT * Math.cos(coords.lat * (Math.PI / 180)))));
          const pointCoords = rotateCoordinates(centerLat, centerLon, latitude, longitude, deviationInput);

          if ((type === 'grid' || type === 'doc') && type !== 'pointsKMZ') {
            kmlContent += getGridPlacemark(colLabel, rowLabel, gridCoords.lon, gridCoords.lat, length, kmlColor, deviationInput, referencePoint);
          }

          if ((type === 'points' || type === 'doc' || type === 'pointsKMZ')) {
            if (isKMZ) {
              const iconHref = getIconHref(colLabel, rowLabel);
              kmlContent += getKMZPointPlacemark(colLabel, rowLabel, pointCoords.lon, pointCoords.lat, iconHref, true, iconSize, transparencyHex);
            } else {
              kmlContent += getTransparentPointPlacemark(colLabel, rowLabel, pointCoords.lon, pointCoords.lat);
            }
          }
        }
      }

      // Ajouter le cercle blanc aux coordonnées entrées par l'utilisateur
      const lineWidth = 2; // Même épaisseur que les lignes de la grille
      const originPoint = { lat: latitude, lon: longitude };

      kmlContent += getOriginCirclePlacemark(originPoint.lat, originPoint.lon, length, deviationInput, lineWidth);

      kmlContent += `</Document></kml>`;
      return kmlContent;
    }

    function rotateCoordinates(lat, lon, refLat, refLon, angle) {
      // Si aucune déviation n'est spécifiée, retourner les coordonnées originales
      if (angle == 0) return { lat, lon };

      const angleRad = angle * (Math.PI / 180);
      const x = (lon - refLon) * METERS_PER_DEGREE_LAT * Math.cos(refLat * (Math.PI / 180));
      const y = (lat - refLat) * METERS_PER_DEGREE_LAT;
      const rotatedX = x * Math.cos(angleRad) + y * Math.sin(angleRad);
      const rotatedY = -x * Math.sin(angleRad) + y * Math.cos(angleRad);
      const rotatedLon = rotatedX / (METERS_PER_DEGREE_LAT * Math.cos(refLat * (Math.PI / 180))) + refLon;
      const rotatedLat = rotatedY / METERS_PER_DEGREE_LAT + refLat;
      return { lat: rotatedLat, lon: rotatedLon };
    }

    function calculateStartingPoint(lat, lon, length, refPoint, rowStart, rowEnd, colStart, colEnd) {
      let startingLat, startingLon;
      let rowIndices = [], colIndices = [];

      // Générer les indices de lignes et de colonnes en excluant le zéro
      rowIndices = generateIndices(rowStart, rowEnd);
      colIndices = generateIndices(colStart, colEnd);

      const totalRows = rowIndices.length;
      const totalCols = colIndices.length;

      switch (refPoint) {
        case "center":
           {
        const totalHeight = totalRows * length;
        const totalWidth = totalCols * length;

        // Pour "center", on se contente de prendre la moitié du total sans ajustement :
        const deltaLat = (totalHeight / 2) / METERS_PER_DEGREE_LAT;
        const deltaLon = (totalWidth / 2) / (METERS_PER_DEGREE_LAT * Math.cos(lat * (Math.PI / 180)));

        startingLat = lat - deltaLat;
        startingLon = lon - deltaLon;
      }
          break;
        case "topLeft":
          {
            // Trouver les indices de A1
            const a1RowIndex = rowIndices.indexOf(1);
            const a1ColIndex = colIndices.indexOf(1);

            if (a1RowIndex === -1 || a1ColIndex === -1) {
              alert("La case A1 n'existe pas dans le quadrillage spécifié.");
              return null;
            }

            const deltaLat = a1RowIndex * length / METERS_PER_DEGREE_LAT;
            const deltaLon = -a1ColIndex * length / (METERS_PER_DEGREE_LAT * Math.cos(lat * (Math.PI / 180)));

            startingLat = lat + deltaLat;
            startingLon = lon + deltaLon;
          }
          break;
        case "origin":
          {
            // Trouver les indices de A1
            const a1RowIndex = rowIndices.indexOf(1);
            const a1ColIndex = colIndices.indexOf(1);

            if (a1RowIndex === -1 || a1ColIndex === -1) {
              alert("La case A1 n'existe pas dans le quadrillage spécifié.");
              return null;
            }

            const deltaLat = -a1RowIndex * length / METERS_PER_DEGREE_LAT;
            const deltaLon = -a1ColIndex * length / (METERS_PER_DEGREE_LAT * Math.cos(lat * (Math.PI / 180)));

            startingLat = lat + deltaLat;
            startingLon = lon + deltaLon;
          }
          break;
      }

      return { startingLat, startingLon, rowIndices, colIndices };
    }

    function generateIndices(start, end) {
      const indices = [];
      if (start <= end) {
        for (let i = start; i <= end; i++) {
          if (i !== 0) indices.push(i);
        }
      } else {
        for (let i = start; i >= end; i--) {
          if (i !== 0) indices.push(i);
        }
      }
      return indices;
    }

    async function validateInputs(coordinates, length) {
        let validCoordinates = coordinates.trim();
    
        // Vérifier si les coordonnées sont en DMS
        if (isDMS(validCoordinates)) {
            try {
                validCoordinates = await convertDMSToDecimal(validCoordinates);
            } catch (error) {
                alert("Erreur de conversion DMS → Décimal. Veuillez entrer des coordonnées valides.");
                return false;
            }
        }
    
        // Vérifier si elles sont maintenant en décimal
        if (!isDecimal(validCoordinates)) {
            alert("Veuillez entrer des coordonnées valides en degrés décimaux ou DMS.");
            return false;
        }
    
        // Vérifier la validité de l'échelle
        if (isNaN(length) || length <= 0) {
            alert("Veuillez entrer une échelle valide.");
            return false;
        }
    
        return true;
    }


    function getGridRowRange() {
      if (document.getElementById("gridOption").value === "default") {
        const { start, end } = parseGridOption(document.getElementById("gridType").value).rows;
        return { rowStart: start, rowEnd: end };
      } else {
        const rowStart = parseInt(document.getElementById("customRowStart").value);
        const rowEnd = parseInt(document.getElementById("customRowEnd").value);

        if (isNaN(rowStart) || isNaN(rowEnd)) {
          alert('Veuillez entrer des nombres valides pour les lignes.');
          return null;
        }

        return {
          rowStart: rowStart,
          rowEnd: rowEnd
        };
      }
    }

    function getGridColRange() {
      if (document.getElementById("gridOption").value === "default") {
        const { start, end } = parseGridOption(document.getElementById("gridType").value).cols;
        return { colStart: start, colEnd: end };
      } else {
        const colStartLabel = document.getElementById("customColStart").value.trim();
        const colEndLabel = document.getElementById("customColEnd").value.trim();

        if (!colStartLabel || !colEndLabel) {
          alert('Veuillez entrer des lettres valides pour les colonnes.');
          return null;
        }

        const colStart = columnLabelToIndex(colStartLabel);
        const colEnd = columnLabelToIndex(colEndLabel);

        return {
          colStart: colStart,
          colEnd: colEnd
        };
      }
    }

    function parseGridOption(option) {
      switch (option) {
        case "Z26": return { rows: { start: 1, end: 26 }, cols: { start: 1, end: 26 } };
        case "Z14": return { rows: { start: 1, end: 14 }, cols: { start: 1, end: 26 } };
        case "Q9": return { rows: { start: 1, end: 9 }, cols: { start: 1, end: 17 } };
        default: return { rows: { start: 1, end: 26 }, cols: { start: 1, end: 26 } };
      }
    }

    function getColumnLabel(index) {
      if (index === 0) {
        return ''; // Pas de colonne zéro
      }

      let isNegative = index < 0;
      index = Math.abs(index);

      let label = '';
      while (index > 0) {
        let modulo = (index - 1) % 26;
        label = String.fromCharCode(65 + modulo) + label;
        index = Math.floor((index - 1) / 26);
      }

      return isNegative ? '-' + label : label;
    }

    function columnLabelToIndex(label) {
      let isNegative = false;
      if (label.startsWith('-')) {
        isNegative = true;
        label = label.substring(1);
      }
      label = label.toUpperCase();
      let index = 0;
      for (let i = 0; i < label.length; i++) {
        let charCode = label.charCodeAt(i) - 64; // 'A' is 65
        index = index * 26 + charCode;
      }
      return isNegative ? -index : index;
    }

    function getRowLabel(index) {
      if (index === 0) {
        return ''; // Pas de ligne zéro
      }
      return index.toString();
    }

    function getGridCellCoordinates(rowIndex, colIndex, startingLat, startingLon, length, rowIndices, colIndices, refPoint) {
      // Trouver l'index de la ligne et de la colonne dans les indices
      const rowPosition = rowIndices.indexOf(rowIndex);
      const colPosition = colIndices.indexOf(colIndex);

      let deltaLat, deltaLon;

      if (refPoint === "topLeft") {
        deltaLat = -rowPosition * length / METERS_PER_DEGREE_LAT;
        deltaLon = colPosition * length / (METERS_PER_DEGREE_LAT * Math.cos(startingLat * (Math.PI / 180)));
      } else {
        deltaLat = rowPosition * length / METERS_PER_DEGREE_LAT;
        deltaLon = colPosition * length / (METERS_PER_DEGREE_LAT * Math.cos(startingLat * (Math.PI / 180)));
      }

      const lat = startingLat + deltaLat;
      const lon = startingLon + deltaLon;

      return { lat, lon };
    }

    function getKMLHeader(color, useIcons, iconSize, transparencyHex, rowStart, rowEnd, colStart, colEnd) {
      const gridNameInput = document.getElementById("gridName").value.trim();
      const filename = gridNameInput || 'Carroyage';
      const length = document.getElementById("length").value;
      const scale = `${length}m`;
      const refPoint = document.getElementById("referencePoint").value;
      const deviation = document.getElementById("deviation").value;
      const angle = `${deviation}°`;
      const gridOption = document.getElementById("gridOption").value;
      const rowRange = getGridRowRange();
      const colRange = getGridColRange();
      const gridType = gridOption === "default" 
                       ? document.getElementById("gridType").value 
                       : `Custom_${rowRange.rowStart}_${rowRange.rowEnd}_${getColumnLabel(colRange.colStart)}_${getColumnLabel(colRange.colEnd)}`;

      return `<?xml version="1.0" encoding="UTF-8"?>
              <kml xmlns="http://www.opengis.net/kml/2.2">
                <Document>
                  <name>${filename}_${scale}_${refPoint}_${angle}_${gridType}</name>
                  <description>Généré par le Générateur de carroyage CADO</description>
                  <Style id="gridLineStyle">
                    <LineStyle>
                      <color>${color}</color>
                      <width>2</width>
                    </LineStyle>
                  </Style>
                  <Style id="cado">
                    <LabelStyle>
                      <scale>${useIcons ? '0' : '1'}</scale>
                    </LabelStyle>
                    <IconStyle>
                      <scale>${useIcons ? iconSize : '0.1'}</scale>
                      <Icon>
                        <href>${useIcons ? '' : 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8Xw8AAocB9mP0V70AAAAASUVORK5CYII='}</href>
                      </Icon>
                      <color>${transparencyHex}ffffff</color>
                      <hotSpot x="0.5" y="0.5" xunits="fraction" yunits="fraction"/>
                    </IconStyle>
                  </Style>`;
    }

    function getGridPlacemark(colLabel, rowLabel, lon, lat, length, color, deviation, refPoint) {
      const lonDelta = length / (METERS_PER_DEGREE_LAT * Math.cos(lat * (Math.PI / 180)));
      const latDelta = length / METERS_PER_DEGREE_LAT;

      let topLeft, topRight, bottomRight, bottomLeft;

      if (refPoint === "topLeft") {
        topLeft = rotateCoordinates(lat, lon, lat, lon, deviation);
        topRight = rotateCoordinates(lat, lon + lonDelta, lat, lon, deviation);
        bottomRight = rotateCoordinates(lat - latDelta, lon + lonDelta, lat, lon, deviation);
        bottomLeft = rotateCoordinates(lat - latDelta, lon, lat, lon, deviation);
      } else {
        topLeft = rotateCoordinates(lat, lon, lat, lon, deviation);
        topRight = rotateCoordinates(lat, lon + lonDelta, lat, lon, deviation);
        bottomRight = rotateCoordinates(lat + latDelta, lon + lonDelta, lat, lon, deviation);
        bottomLeft = rotateCoordinates(lat + latDelta, lon, lat, lon, deviation);
      }

      return `<Placemark>
                <name>${colLabel}${rowLabel}</name>
                <Style>
                  <LineStyle>
                    <color>${color}</color>
                    <width>2</width>
                  </LineStyle>
                </Style>
                <LineString>
                  <coordinates>
                    ${topLeft.lon},${topLeft.lat}
                    ${topRight.lon},${topRight.lat}
                    ${bottomRight.lon},${bottomRight.lat}
                    ${bottomLeft.lon},${bottomLeft.lat}
                    ${topLeft.lon},${topLeft.lat}
                  </coordinates>
                </LineString>
              </Placemark>`;
    }

    function getTransparentPointPlacemark(colLabel, rowLabel, lon, lat) {
      // Utiliser une icône transparente intégrée en base64
      const transparentIconBase64 = "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8Xw8AAocB9mP0V70AAAAASUVORK5CYII=";
      return `<Placemark>
                <name>${colLabel}${rowLabel}</name>
                <Style>
                  <IconStyle>
                    <scale>0.1</scale>
                    <Icon>
                      <href>data:image/png;base64,${transparentIconBase64}</href>
                    </Icon>
                  </IconStyle>
                  <LabelStyle>
                    <scale>1</scale>
                  </LabelStyle>
                </Style>
                <Point>
                  <coordinates>${lon},${lat}</coordinates>
                </Point>
              </Placemark>`;
    }

    function getKMZPointPlacemark(colLabel, rowLabel, lon, lat, iconHref, hideLabel, iconSize, transparencyHex) {
      return `<Placemark>
                ${hideLabel ? '' : `<name>${colLabel}${rowLabel}</name>`}
                <Style>
                  <IconStyle>
                    <scale>${iconSize}</scale>
                    <Icon>
                      <href>${iconHref}</href>
                    </Icon>
                    <color>${transparencyHex}ffffff</color>
                  </IconStyle>
                </Style>
                <Point>
                  <coordinates>${lon},${lat}</coordinates>
                </Point>
              </Placemark>`;
    }

    // Fonction pour obtenir le nom de fichier d'icône en utilisant les étiquettes directement
    function getIconHref(colLabel, rowLabel) {
      const iconName = `${colLabel}${rowLabel}.png`;
      return `icons/${iconName}`;
    }
    
    // Fonction pour générer le cercle blanc aux coordonnées entrées par l'utilisateur (contour uniquement)
    function getOriginCirclePlacemark(lat, lon, length, deviation, lineWidth) {
      const circleColor = 'ffffffff'; // Blanc opaque en format KML (aabbggrr)
      const radius = (length / 5) / METERS_PER_DEGREE_LAT; // Rayon en degrés

      const numPoints = 36; // Nombre de points pour approximer le cercle
      const angleStep = 360 / numPoints;

      let coordinates = '';
      for (let i = 0; i <= numPoints; i++) {
        const angleDeg = i * angleStep;
        const angleRad = (angleDeg + parseFloat(deviation)) * (Math.PI / 180);
        const pointLat = lat + (radius * Math.cos(angleRad));
        const pointLon = lon + (radius * Math.sin(angleRad)) / Math.cos(lat * (Math.PI / 180));
        coordinates += `${pointLon},${pointLat} `;
      }

      const circlePlacemark = `
        <Placemark>
          <name>Point de référence</name>
          <Style>
            <LineStyle>
              <color>${circleColor}</color>
              <width>${lineWidth}</width>
            </LineStyle>
            <PolyStyle>
              <fill>0</fill> <!-- Ne pas remplir l'intérieur du polygone -->
            </PolyStyle>
          </Style>
          <Polygon>
            <outerBoundaryIs>
              <LinearRing>
                <coordinates>
                  ${coordinates.trim()}
                </coordinates>
              </LinearRing>
            </outerBoundaryIs>
          </Polygon>
        </Placemark>
      `;

      return circlePlacemark;
    }
function updatePlaceholder() {
    const type = document.getElementById("coordType").value;
    const inputField = document.getElementById("coordinates");
  
    switch (type) {
      case "dms":
        inputField.placeholder = "48°48'12.5\"N, 2°17'40.3\"E";
        break;
      case "pluscode":
        inputField.placeholder = "8FW4VMC5+G6";
        break;
      case "address":
        inputField.placeholder = "Tour Eiffel, Paris";
        break;
      default:
        inputField.placeholder = "48.803322, 2.126005";
    }
  }
function validateInput() {
    const inputField = document.getElementById("coordinates");
    const convertButton = document.getElementById("convertButton");
    const inputValue = inputField.value.trim();

    if (isDecimal(inputValue)) {
        convertButton.textContent = "Convertir en DMS";
        convertButton.classList.add("active");
        convertButton.disabled = false;
    } else if (isDMS(inputValue)) {
        convertButton.textContent = "Convertir en décimal";
        convertButton.classList.add("active");
        convertButton.disabled = false;
    } else {
        convertButton.textContent = "Convertir";
        convertButton.classList.remove("active");
        convertButton.disabled = true;
    }
}


function convertCoordinates() {
      const inputField = document.getElementById("coordinates");
      let inputValue = inputField.value.trim();
  
      if (isDecimal(inputValue)) {
          inputField.value = convertDecimalToDMS(inputValue);
      } else if (isDMS(inputValue)) {
          inputField.value = convertDMSToDecimal(inputValue);
      }
  
      // **Mise à jour immédiate du bouton après conversion**
      validateInput();
  }



function convertDMSToDecimal(dms) {
  const regex = /(\\d+)°\\s*(\\d+)'\\s*(\\d+(?:\\.\\d+)?)\"?\\s*([NSEW])/gi;
  let result = [];
  let match;

  while ((match = regex.exec(dms)) !== null) {
    let degrees = parseFloat(match[1]);
    let minutes = parseFloat(match[2]) / 60;
    let seconds = parseFloat(match[3]) / 3600;
    let direction = match[4];
    let decimal = degrees + minutes + seconds;
    if (direction === "S" || direction === "W") decimal *= -1;
    result.push(decimal);
  }

  return result.length === 2 ? result.join(", ") : "";
}

async function convertPlusCodeToDecimal(pluscode) {
  // Nécessite un appel API pour la conversion réelle
  alert("Conversion du PlusCode en coordonnées non implémentée.");
  return "";
}

async function convertAddressToDecimal(address) {
  // Nécessite un appel API pour la conversion réelle
  alert("Conversion d'adresse en coordonnées non implémentée.");
  return "";
}

function getKMLFilename(type) {
  const gridNameInput = document.getElementById("gridName").value.trim();
  const filename = gridNameInput || 'Carroyage';

  const coordinatesInput = document.getElementById("coordinates").value;
  const [latitude, longitude] = coordinatesInput.split(',').map(coord => parseFloat(coord.trim()).toFixed(6)); // Arrondi à 6 chiffres

  const length = document.getElementById("length").value;
  const scale = `${length}m`;
  const refPoint = document.getElementById("referencePoint").value;
  const deviation = document.getElementById("deviation").value;
  const angle = `${deviation}°`;
  const gridOption = document.getElementById("gridOption").value;
  const rowRange = getGridRowRange();
  const colRange = getGridColRange();
  const gridType = gridOption === "default" 
                       ? document.getElementById("gridType").value 
                       : `Custom_${rowRange.rowStart}_${rowRange.rowEnd}_${getColumnLabel(colRange.colStart)}_${getColumnLabel(colRange.colEnd)}`;

  const coordsString = `${latitude}_${longitude}`; // Ajoutez les coordonnées arrondies dans le nom

  if (type === 'grid') {
    return `${filename}_${coordsString}_KML-Grille_${scale}_${refPoint}_${angle}_${gridType}.kml`;
  } else if (type === 'points') {
    return `${filename}_${coordsString}_KML-Points_${scale}_${refPoint}_${angle}_${gridType}.kml`;
  } else if (type === 'pointsKMZ') {
    return `${filename}_${coordsString}_KMZ-Points_${scale}_${refPoint}_${angle}_${gridType}.kmz`;
  } else {
    return `${filename}_${coordsString}_KMZ_${scale}_${refPoint}_${angle}_${gridType}.kmz`;
  }
}


    function downloadFile(content, filename, mimeType) {
      const element = document.createElement('a');
      element.setAttribute('href', URL.createObjectURL(new Blob([content], {type: mimeType})));
      element.setAttribute('download', filename);
      document.body.appendChild(element);
      element.click();
      document.body.removeChild(element);
    }
  </script>
</head>
<body>
  <h1>Générateur de carroyage CADO  <a href="guide_utilisation.pdf" download class="help-button">?</a></h1>

  <div class="button-container">
    <button onclick="window.open('https://maps.google.com', '_blank')">Ouvrir Google Maps</button>
    <button onclick="window.open('https://www.google.com/mymaps', '_blank')">Ouvrir Google MyMaps</button>
    <button onclick="window.open('https://earth.google.com/web/', '_blank')">Ouvrir Google Earth</button>
  </div>

 <label for="coordinates">Coordonnées :</label>
  <div class="coord-container">
    <input type="text" id="coordinates" placeholder="Degrés décimaux ou DMS" oninput="validateInput()" aria-label="Coordonnées" required>
    <button id="convertButton" onclick="convertCoordinates()" disabled>Convertir</button>
  </div>

  <label for="length">Échelle (en mètres) :</label>
  <input type="number" id="length" placeholder="Spécifier l'échelle" aria-label="Échelle" required min="1">
  
  <label for="color">Choisir une couleur :</label>
  <input type="color" id="color" aria-label="Couleur" value="#FFFFFF">
  
  <div class="slider-container">
    <label for="transparency">Transparence :</label>
    <input type="range" id="transparency" min="0" max="100" value="20" aria-label="Transparence" oninput="updateSliderValue('transparency', 'transparencyValue', '%')">
    <div class="slider-value" id="transparencyValue">20%</div>
  </div>

  <label for="gridName">Nom du carroyage :</label>
  <input type="text" id="gridName" placeholder="Nom du carroyage (optionnel)" aria-label="Nom du carroyage">

  <label for="referencePoint">Point de référence :</label>
  <select id="referencePoint" aria-label="Point de référence">
    <option value="center">Milieu du carroyage</option>
    <option value="topLeft">Coin haut gauche</option>
    <option value="origin">Origine (A1)</option>
  </select>
  
  <label for="gridOption">Option de grille :</label>
  <select id="gridOption" aria-label="Option de grille" onchange="toggleCustomGridOptions()">
    <option value="default">Grille par défaut</option>
    <option value="custom">Grille custom</option>
  </select>

  <div id="defaultGridOptions">
    <label for="gridType">Type de grille :</label>
    <select id="gridType" aria-label="Type de grille">
      <option value="Z26">Z26 (26x26)</option>
      <option value="Z14" selected>Z14 (26x14)</option>
      <option value="Q9">Q9 (17x9)</option>
    </select>
  </div>

  <div id="customGridOptions" style="display:none;">
    <label for="customRowStart">Début des lignes (nombres) :</label>
    <input type="number" id="customRowStart" value="1">
    <label for="customRowEnd">Fin des lignes (nombres) :</label>
    <input type="number" id="customRowEnd" value="26">
    <label for="customColStart">Début des colonnes (lettres) :</label>
    <input type="text" id="customColStart" value="A">
    <label for="customColEnd">Fin des colonnes (lettres) :</label>
    <input type="text" id="customColEnd" value="Z">
  </div>
  
  <p id="customGridHint" style="display:none; font-size: 0.9em; color: #888;">
      * Pour une grille personnalisée :
      - Les lignes peuvent aller de -26 à 52.
      - Les colonnes doivent être comprises entre -Z et AZ.
  </p>

  <div class="slider-container">
    <label for="deviation">Déviation (en degrés) :</label>
    <input type="range" id="deviation" min="-180" max="180" value="0" aria-label="Déviation" oninput="updateSliderValue('deviation', 'deviationValue', '°')">
    <div class="slider-value" id="deviationValue">0°</div>
  </div>

  <label for="iconSize">Taille des icônes :</label>
  <input type="range" id="iconSize" min="1" max="5" value="2" step="0.1" aria-label="Taille des icônes" oninput="updateSliderValue('iconSize', 'iconSizeValue')">
  <div class="slider-value" id="iconSizeValue">2</div>

  <!-- Le champ pour le fichier ZIP des icônes a été supprimé, car les données sont chargées depuis data_black.js -->

  <div class="button-container">
    <button onclick="generateKML('grid')">Générer KML Grille</button>
    <button onclick="generateKML('points')">Générer KML Points</button>
    <button onclick="generateKMZ('pointsKMZ')">Générer KMZ Points</button>
    <button onclick="generateKMZ('doc')">Générer KMZ Grille + Points</button>
  </div>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Générateur de carroyage CADO V10</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/flowbite/1.6.5/flowbite.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    
    <!-- Bibliothèque Open Location Code pour la conversion des Plus Codes -->
    <script src="https://cdn.jsdelivr.net/npm/open-location-code@1.0.4/js/openlocationcode.min.js"></script>
    
    <!-- Chargement direct des fichiers JS d'icônes -->
    <script src="FFFFFF-images.js"></script>
    <script src="000000-images.js"></script>
    <script src="FF0000-images.js"></script>
    <script src="FFA500-images.js"></script>
    <script src="FFFF00-images.js"></script>
    <script src="008000-images.js"></script>
    <script src="0000FF-images.js"></script>
    <script src="800080-images.js"></script>
    <script src="A52A2A-images.js"></script>
    <script src="808080-images.js"></script>
    
    <script>
        // Dictionnaires pour stocker les icônes par couleur
        const iconDictionaries = {};
        
        // Fonction pour initialiser les dictionnaires d'icônes
        function initIconDictionaries() {
            // Liste des variables d'icônes attendues (chaque fichier JS déclare sa propre variable)
            const iconDataSources = {
                'FFFFFF': imageBase64DataFFFFFF,
                '000000': imageBase64Data000000,
                'FF0000': imageBase64DataFF0000,
                'FFA500': imageBase64DataFFA500,
                'FFFF00': imageBase64DataFFFF00,
                '008000': imageBase64Data008000,
                '0000FF': imageBase64Data0000FF,
                '800080': imageBase64Data800080,
                'A52A2A': imageBase64DataA52A2A,
                '808080': imageBase64Data808080
            };
            
            // Créer un dictionnaire pour chaque couleur
            for (const [colorHex, data] of Object.entries(iconDataSources)) {
                if (data) {
                    // Créer un dictionnaire pour cette couleur
                    const dict = {};
                    data.forEach(item => {
                        dict[item.name] = item.base64;
                    });
                    
                    // Stocker le dictionnaire
                    iconDictionaries[colorHex] = dict;
                    console.log(`Dictionnaire créé pour ${colorHex} avec ${Object.keys(dict).length} icônes`);
                } else {
                    console.warn(`Données manquantes pour ${colorHex}`);
                }
            }
        }
        
        // Initialiser les dictionnaires au chargement de la page
        document.addEventListener('DOMContentLoaded', initIconDictionaries);
    </script>
    
    <style>
        :root {
            /* Common colors */
            --primary-color: #5D5CDE;
            --primary-color-hover: #4a49c0;
            
            /* Light theme colors */
            --light-bg: #FFFFFF;
            --light-card-bg: #f8f9fa;
            --light-text: #333333;
            --light-text-secondary: #555555;
            --light-border: #e2e8f0;
            --light-input-bg: #f1f5f9;
            --light-button-bg: #e9ecef;
            --light-button-hover: #dee2e6;
            
            /* Dark theme colors */
            --dark-bg: #181818;
            --dark-card-bg: #2d2d2d;
            --dark-text: #f1f1f1;
            --dark-text-secondary: #d1d5db;
            --dark-border: #4d4d4d;
            --dark-input-bg: #3d3d3d;
            --dark-button-bg: #3d3d3d;
            --dark-button-hover: #4d4d4d;
        }
        
        /* Light theme (default) */
        body {
            background-color: var(--light-bg);
            color: var(--light-text);
        }
        
        /* Dark theme */
        .dark-mode {
            background-color: var(--dark-bg);
            color: var(--dark-text);
        }
        
        /* Rainbow colors for color selection */
        .color-option {
            width: 30px;
            height: 30px;
            cursor: pointer;
            border: 2px solid transparent;
            border-radius: 50%;
            transition: all 0.2s ease;
        }
        
        .color-option.selected {
            border-color: var(--primary-color) !important;
            box-shadow: 0 0 0 2px rgba(93, 92, 222, 0.5) !important;
            transform: scale(1.1) !important;
        }
        
        .dark .color-option.selected {
            border-color: var(--primary-color) !important;
            box-shadow: 0 0 0 2px rgba(93, 92, 222, 0.8) !important;
        }
        
        /* Style for selected radio buttons */
        .option-selected {
            background-color: #5D5CDE !important;
            color: white !important;
            border-color: #5D5CDE !important;
        }
        
        /* Radio inputs and their labels */
        input[type="radio"] {
            display: none;
        }
        
        input[type="radio"] + span {
            display: inline-block;
            transition: all 0.2s ease;
        }
        
        input[type="radio"]:checked + span {
            background-color: #5D5CDE !important;
            color: white !important;
            border-color: #5D5CDE !important;
        }
        
        @media (prefers-color-scheme: dark) {
            body {
                background-color: var(--dark-bg);
                color: var(--dark-text);
            }
            
            .card {
                background-color: var(--dark-card-bg) !important;
                border-color: var(--dark-border) !important;
            }
            
            .input-field {
                background-color: var(--dark-input-bg) !important;
                color: var(--dark-text) !important;
                border-color: var(--dark-border) !important;
            }
            
            .input-field::placeholder {
                color: var(--dark-text-secondary) !important;
            }
            
            .button-outline {
                border-color: var(--dark-border) !important;
                color: var(--dark-text) !important;
                background-color: var(--dark-button-bg) !important;
            }
            
            .button-outline:hover {
                background-color: var(--dark-button-hover) !important;
            }
            
            .text-content {
                color: var(--dark-text) !important;
            }
            
            .text-secondary {
                color: var(--dark-text-secondary) !important;
            }
            
            .border-default {
                border-color: var(--dark-border) !important;
            }
            
            .reset-btn {
                background-color: var(--dark-button-bg) !important;
                color: var(--dark-text) !important;
            }
            
            .reset-btn:hover {
                background-color: var(--dark-button-hover) !important;
            }
        }
        
        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: var(--primary-color);
            animation: spin 1s linear infinite;
        }
        
        @media (prefers-color-scheme: dark) {
            .loading-spinner {
                border-color: rgba(255, 255, 255, 0.1);
                border-left-color: var(--primary-color);
            }
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>
<body class="p-4 md:p-6">
    <div class="max-w-5xl mx-auto">
        <header class="mb-6 text-center">
            <h1 class="text-2xl md:text-3xl font-bold mb-4 text-content">Générateur de carroyage CADO V10</h1>
            <div class="flex flex-wrap justify-center gap-2 mb-4">
                <button id="helpBtn" class="text-2xl px-3 py-1 rounded-full button-outline bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-white">?</button>
                <a href="https://www.google.com/maps" target="_blank" class="px-3 py-1 button-outline bg-gray-200 hover:bg-gray-300 rounded dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-white text-sm md:text-base">Ouvrir Google Maps</a>
                <a href="https://www.google.com/mymaps" target="_blank" class="px-3 py-1 button-outline bg-gray-200 hover:bg-gray-300 rounded dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-white text-sm md:text-base">Ouvrir Google MyMaps</a>
                <a href="https://earth.google.com/web/" target="_blank" class="px-3 py-1 button-outline bg-gray-200 hover:bg-gray-300 rounded dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-white text-sm md:text-base">Ouvrir Google Earth</a>
            </div>
        </header>

        <main class="card bg-white shadow-md rounded-lg p-4 md:p-6 dark:bg-gray-800 dark:border dark:border-gray-700">
            <section class="mb-6">
                <h3 class="text-lg font-semibold mb-3 text-content">Coordonnées</h3>
                <div class="space-y-4">
                    <div class="flex flex-col md:flex-row md:items-center space-y-2 md:space-y-0">
                        <label class="md:w-1/3 text-sm md:text-base text-content">Coordonnées GPS (décimal) :</label>
                        <div class="md:w-2/3 flex space-x-2">
                            <input type="text" id="decimal-coords" class="input-field w-full px-3 py-2 border rounded shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white text-base" placeholder="Lat, Long (ex: 48.8566, 2.3522)">
                            <button id="convert-from-decimal" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded text-sm md:text-base">Convertir</button>
                            <button id="view-on-maps-decimal" class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-sm md:text-base">Voir sur Maps</button>
                        </div>
                    </div>
                    <div class="flex flex-col md:flex-row md:items-center space-y-2 md:space-y-0">
                        <label class="md:w-1/3 text-sm md:text-base text-content">Coordonnées GPS (DMS) :</label>
                        <div class="md:w-2/3 flex space-x-2">
                            <input type="text" id="dms-coords" class="input-field w-full px-3 py-2 border rounded shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white text-base" placeholder="ex: 48°51'23.7''N 2°21'07.9''E">
                            <button id="convert-from-dms" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded text-sm md:text-base">Convertir</button>
                            <button id="view-on-maps-dms" class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-sm md:text-base">Voir sur Maps</button>
                        </div>
                    </div>
                    <div class="flex flex-col md:flex-row md:items-center space-y-2 md:space-y-0">
                        <label class="md:w-1/3 text-sm md:text-base text-content">Plus Code :</label>
                        <div class="md:w-2/3 flex space-x-2">
                            <input type="text" id="plus-code" class="input-field w-full px-3 py-2 border rounded shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white text-base" placeholder="ex: 8FW4V75V+ ou EW47+QV Paris">
                            <button id="convert-from-plus" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded text-sm md:text-base">Convertir</button>
                            <button id="view-on-maps-plus" class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-sm md:text-base">Voir sur Maps</button>
                        </div>
                    </div>
                    <div class="flex flex-col md:flex-row md:items-center space-y-2 md:space-y-0">
                        <label class="md:w-1/3 text-sm md:text-base text-content">Coordonnées MERCATOR :</label>
                        <div class="md:w-2/3 flex space-x-2">
                            <input type="text" id="mercator-coords" class="input-field w-full px-3 py-2 border rounded shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white text-base" placeholder="ex: 263726.05, 6250958.43">
                            <button id="convert-from-mercator" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded text-sm md:text-base">Convertir</button>
                            <button id="view-on-maps-mercator" class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-sm md:text-base">Voir sur Maps</button>
                        </div>
                    </div>
                </div>
            </section>

            <section class="mb-6">
                <h3 class="text-lg font-semibold mb-3 text-content">Configuration du carroyage</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="space-y-3">
                        <div class="flex flex-col space-y-1">
                            <label class="text-sm md:text-base text-content">Échelle (en mètres) :</label>
                            <input type="number" id="scale" class="input-field px-3 py-2 border rounded shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white text-base grid-parameter" value="20">
                        </div>
                        
                        <div class="flex flex-col space-y-1">
                            <label class="text-sm md:text-base text-content">Choisir une couleur :</label>
                            <div class="flex flex-wrap gap-2" id="color-options">
                                <div class="color-option selected" data-color="#FFFFFF" data-name="white" style="background-color: #FFFFFF; border: 1px solid #ccc;"></div>
                                <div class="color-option" data-color="#000000" data-name="black" style="background-color: #000000;"></div>
                                <div class="color-option" data-color="#FF0000" data-name="red" style="background-color: #FF0000;"></div>
                                <div class="color-option" data-color="#FFA500" data-name="orange" style="background-color: #FFA500;"></div>
                                <div class="color-option" data-color="#FFFF00" data-name="yellow" style="background-color: #FFFF00;"></div>
                                <div class="color-option" data-color="#008000" data-name="green" style="background-color: #008000;"></div>
                                <div class="color-option" data-color="#0000FF" data-name="blue" style="background-color: #0000FF;"></div>
                                <div class="color-option" data-color="#800080" data-name="violet" style="background-color: #800080;"></div>
                                <div class="color-option" data-color="#A52A2A" data-name="brown" style="background-color: #A52A2A;"></div>
                                <div class="color-option" data-color="#808080" data-name="gray" style="background-color: #808080;"></div>
                            </div>
                            <input type="hidden" id="grid-color" value="#FFFFFF">
                            <input type="hidden" id="grid-color-name" value="white" class="grid-parameter">
                        </div>
                        
                        <div class="flex flex-col space-y-1">
                            <label class="text-sm md:text-base text-content">Transparence :</label>
                            <div class="flex space-x-2 items-center">
                                <input type="range" id="transparency" class="w-full grid-parameter" min="0" max="100" value="20">
                                <span id="transparency-value" class="text-sm text-content">20%</span>
                            </div>
                        </div>
                        
                        <div class="flex space-x-4">
                            <div class="flex-1 flex flex-col space-y-1">
                                <label class="text-sm md:text-base text-content">Taille du texte :</label>
                                <input type="number" id="label-size" class="input-field px-3 py-2 border rounded shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white text-base grid-parameter" value="1.2" min="0.5" max="3" step="0.1">
                            </div>
                            <div class="flex-1 flex flex-col space-y-1">
                                <label class="text-sm md:text-base text-content">Taille des icônes :</label>
                                <input type="number" id="icon-size" class="input-field px-3 py-2 border rounded shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white text-base grid-parameter" value="2" min="0.5" max="5" step="0.1">
                            </div>
                        </div>
                        
                        <div class="flex flex-col space-y-1">
                            <label class="text-sm md:text-base text-content">Nom du carroyage :</label>
                            <input type="text" id="grid-name-base" class="input-field px-3 py-2 border rounded shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white text-base grid-parameter" value="CADO Grid">
                            <input type="hidden" id="grid-name" value="CADO Grid">
                            <div id="full-grid-name" class="text-sm text-secondary mt-1 overflow-auto max-h-20 border-l-2 border-blue-500 pl-2 italic">CADO Grid_20m_center_Z14_white</div>
                        </div>
                    </div>
                    
                    <div class="space-y-3">
                        <div class="flex flex-col space-y-1">
                            <label class="text-sm md:text-base text-content">Point de référence :</label>
                            <div class="flex flex-wrap gap-2">
                                <label class="inline-flex items-center">
                                    <input type="radio" name="reference-point" value="center" class="custom-radio grid-parameter" checked>
                                    <span class="px-3 py-1 border border-default rounded cursor-pointer text-sm button-outline">Milieu du carroyage</span>
                                </label>
                                <label class="inline-flex items-center">
                                    <input type="radio" name="reference-point" value="origin" class="custom-radio grid-parameter">
                                    <span class="px-3 py-1 border border-default rounded cursor-pointer text-sm button-outline">Origine (A1)</span>
                                </label>
                            </div>
                        </div>
                        
                        <div class="flex flex-col space-y-1">
                            <label class="text-sm md:text-base text-content">Orientation des lettres :</label>
                            <div class="flex gap-2">
                                <label class="inline-flex items-center">
                                    <input type="radio" name="lettering-direction" value="ascending" class="custom-radio grid-parameter" checked>
                                    <span class="px-3 py-1 border border-default rounded cursor-pointer text-sm button-outline">Ascendante (Sud→Nord)</span>
                                </label>
                                <label class="inline-flex items-center">
                                    <input type="radio" name="lettering-direction" value="descending" class="custom-radio grid-parameter">
                                    <span class="px-3 py-1 border border-default rounded cursor-pointer text-sm button-outline">Descendante (Nord→Sud)</span>
                                </label>
                            </div>
                        </div>
                        
                        <div class="flex flex-col space-y-1">
                            <label class="text-sm md:text-base text-content">Option de grille :</label>
                            <div class="flex gap-2">
                                <label class="inline-flex items-center">
                                    <input type="radio" name="grid-option" value="default" class="custom-radio grid-parameter" checked>
                                    <span class="px-3 py-1 border border-default rounded cursor-pointer text-sm button-outline">Grille par défaut</span>
                                </label>
                                <label class="inline-flex items-center">
                                    <input type="radio" name="grid-option" value="custom" class="custom-radio grid-parameter">
                                    <span class="px-3 py-1 border border-default rounded cursor-pointer text-sm button-outline">Grille custom</span>
                                </label>
                            </div>
                        </div>
                        
                        <div id="default-grid-options" class="flex flex-col space-y-1">
                            <label class="text-sm md:text-base text-content">Type de grille :</label>
                            <div class="flex flex-wrap gap-2">
                                <label class="inline-flex items-center">
                                    <input type="radio" name="grid-type" value="Z26" class="custom-radio grid-parameter">
                                    <span class="px-3 py-1 border border-default rounded cursor-pointer text-sm button-outline">Z26 (26x26)</span>
                                </label>
                                <label class="inline-flex items-center">
                                    <input type="radio" name="grid-type" value="Z14" class="custom-radio grid-parameter" checked>
                                    <span class="px-3 py-1 border border-default rounded cursor-pointer text-sm button-outline">Z14 (26x14)</span>
                                </label>
                                <label class="inline-flex items-center">
                                    <input type="radio" name="grid-type" value="Q9" class="custom-radio grid-parameter">
                                    <span class="px-3 py-1 border border-default rounded cursor-pointer text-sm button-outline">Q9 (17x9)</span>
                                </label>
                            </div>
                        </div>
                        
                        <div id="custom-grid-options" class="hidden space-y-3">
                            <div class="grid grid-cols-2 gap-2">
                                <div class="flex flex-col space-y-1">
                                    <label class="text-sm text-content">Début des lignes (nombres) :</label>
                                    <input type="number" id="start-row" class="input-field px-3 py-2 border rounded shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white text-base grid-parameter" value="1">
                                </div>
                                <div class="flex flex-col space-y-1">
                                    <label class="text-sm text-content">Fin des lignes (nombres) :</label>
                                    <input type="number" id="end-row" class="input-field px-3 py-2 border rounded shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white text-base grid-parameter" value="26">
                                </div>
                                <div class="flex flex-col space-y-1">
                                    <label class="text-sm text-content">Début des colonnes (lettres) :</label>
                                    <input type="text" id="start-col" class="input-field px-3 py-2 border rounded shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white text-base grid-parameter" value="A">
                                </div>
                                <div class="flex flex-col space-y-1">
                                    <label class="text-sm text-content">Fin des colonnes (lettres) :</label>
                                    <input type="text" id="end-col" class="input-field px-3 py-2 border rounded shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white text-base grid-parameter" value="Z">
                                </div>
                            </div>
                            <p class="text-xs text-secondary">
                                * Pour une grille personnalisée :<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Les lignes peuvent aller de -26 à 52.<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Les colonnes doivent être comprises entre -Z et AZ.<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Il n'y a pas de ligne/colonne 0.
                            </p>
                        </div>
                        
                        <div class="flex flex-col space-y-1">
                            <div class="flex items-center justify-between">
                                <label class="text-sm md:text-base text-content">Déviation (en degrés) :</label>
                                <button id="reset-deviation" class="px-2 py-1 text-xs bg-gray-200 hover:bg-gray-300 rounded dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-white reset-btn">Réinitialiser</button>
                            </div>
                            <div class="flex space-x-2 items-center">
                                <input type="range" id="deviation" class="w-full grid-parameter" min="-180" max="180" value="0">
                                <span id="deviation-value" class="text-sm text-content">0°</span>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <section class="mb-6">
                <h3 class="text-lg font-semibold mb-3 text-content">Format de sortie</h3>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="space-y-2">
                        <h4 class="font-medium text-content">Format du fichier :</h4>
                        <div class="flex flex-wrap gap-2">
                            <label class="inline-flex items-center">
                                <input type="radio" name="file-format" value="KML" class="custom-radio">
                                <span class="px-3 py-1 border border-default rounded cursor-pointer text-sm button-outline w-24 text-center">KML</span>
                            </label>
                            <label class="inline-flex items-center">
                                <input type="radio" name="file-format" value="KMZ" class="custom-radio" checked>
                                <span class="px-3 py-1 border border-default rounded cursor-pointer text-sm button-outline w-24 text-center">KMZ</span>
                            </label>
                            <label class="inline-flex items-center">
                                <input type="radio" name="file-format" value="GeoJSON" class="custom-radio">
                                <span class="px-3 py-1 border border-default rounded cursor-pointer text-sm button-outline w-24 text-center">GeoJSON</span>
                            </label>
                            <label class="inline-flex items-center">
                                <input type="radio" name="file-format" value="GPX" class="custom-radio">
                                <span class="px-3 py-1 border border-default rounded cursor-pointer text-sm button-outline w-24 text-center">GPX (OSMAND)</span>
                            </label>
                        </div>
                    </div>
                    
                    <div class="space-y-2">
                        <h4 class="font-medium text-content">Contenu :</h4>
                        <div class="flex flex-wrap gap-2">
                            <label class="inline-flex items-center">
                                <input type="radio" name="content-type" value="grid-only" class="custom-radio">
                                <span class="px-3 py-1 border border-default rounded cursor-pointer text-sm button-outline w-28 text-center">Grille seule</span>
                            </label>
                            <label class="inline-flex items-center">
                                <input type="radio" name="content-type" value="points-only" class="custom-radio">
                                <span class="px-3 py-1 border border-default rounded cursor-pointer text-sm button-outline w-28 text-center">Points seuls</span>
                            </label>
                            <label class="inline-flex items-center">
                                <input type="radio" name="content-type" value="grid-points" class="custom-radio" checked>
                                <span class="px-3 py-1 border border-default rounded cursor-pointer text-sm button-outline w-28 text-center">Grille + Points</span>
                            </label>
                        </div>
                    </div>
                </div>
            </section>

            <section class="flex justify-center">
                <button id="generate-button" class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-lg text-lg font-semibold shadow-lg transform transition duration-200 hover:scale-105">GÉNÉRER</button>
            </section>
            
            <div id="loading-indicator" class="hidden mt-4 flex flex-col items-center">
                <div class="loading-spinner mb-2"></div>
                <p class="text-sm text-secondary">Génération du carroyage en cours...</p>
            </div>
            
            <div id="error-message" class="hidden mt-4 p-3 bg-red-100 text-red-700 rounded-lg text-center dark:bg-red-900 dark:text-red-300">
            </div>
        </main>
        
        <!-- Help Modal -->
        <div id="help-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
            <div class="card bg-white dark:bg-gray-800 rounded-lg shadow-lg max-w-2xl w-full max-h-[90vh] overflow-y-auto p-6">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-semibold text-content">Aide - Générateur de carroyage CADO</h3>
                    <button id="close-help" class="text-gray-400 hover:text-gray-500 dark:text-gray-300 dark:hover:text-gray-200">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                <div class="prose dark:prose-invert max-w-none">
                    <h3 class="text-content border-b pb-1 mb-3">À propos :</h3>
                    <p class="text-content">
                        Cet outil permet de générer un carroyage géographique à partir d'un point de référence. 
                        Le carroyage est composé de lignes horizontales et verticales formant une grille, 
                        avec des points centraux nommés par une combinaison de lettre et de nombre.
                    </p>
                    
                    <h3 class="text-content border-b pb-1 mt-4 mb-3">Mode d'emploi :</h3>
                    <ol class="text-content list-decimal pl-5 space-y-2">
                        <li>
                            <strong>Entrez les coordonnées</strong> dans l'un des formats disponibles :
                            <ul class="list-disc pl-5 mt-1">
                                <li>Décimal (ex: 48.8566, 2.3522)</li>
                                <li>DMS (ex: 48°51'23.7''N 2°21'07.9''E)</li>
                                <li>Plus Code (ex: Q4J9+9F ou Q4J9+9F Versailles)</li>
                            </ul>
                        </li>
                        <li>
                            <strong>Configurez le carroyage</strong> selon vos besoins :
                            <ul class="list-disc pl-5 mt-1">
                                <li>Échelle (taille des cellules en mètres)</li>
                                <li>Couleur et transparence</li>
                                <li>Taille du texte et des icônes</li>
                                <li>Référence et orientation</li>
                            </ul>
                        </li>
                        <li>
                            Choisissez une <strong>grille prédéfinie</strong> ou <strong>personnalisée</strong>
                        </li>
                        <li>
                            Sélectionnez le <strong>format de sortie</strong> souhaité et le contenu
                        </li>
                        <li>
                            Cliquez sur <strong>GÉNÉRER</strong> pour créer et télécharger le fichier
                        </li>
                    </ol>
                    
                    <h3 class="text-content border-b pb-1 mt-4 mb-3">Grilles prédéfinies :</h3>
                    <ul class="text-content list-disc pl-5 space-y-1">
                        <li><strong>Z26</strong> - grille 26×26 (de A à Z pour les colonnes, de 1 à 26 pour les lignes)</li>
                        <li><strong>Z14</strong> - grille 26×14 (de A à Z pour les colonnes, de 1 à 14 pour les lignes)</li>
                        <li><strong>Q9</strong> - grille 17×9 (de A à Q pour les colonnes, de 1 à 9 pour les lignes)</li>
                    </ul>
                    
                    <h3 class="text-content border-b pb-1 mt-4 mb-3">Grille personnalisée :</h3>
                    <p class="text-content">
                        Vous pouvez définir une grille personnalisée en spécifiant :
                    </p>
                    <ul class="text-content list-disc pl-5 space-y-1">
                        <li>Les lignes : de -26 à 52 (pas de ligne 0)</li>
                        <li>Les colonnes : de -Z à AZ (pas de colonne 0)</li>
                    </ul>
                    
                    <h3 class="text-content border-b pb-1 mt-4 mb-3">Formats de fichiers :</h3>
                    <ul class="text-content list-disc pl-5 space-y-1">
                        <li><strong>KMZ</strong> - Format compressé pour Google Earth avec icônes intégrées</li>
                        <li><strong>KML</strong> - Format pour Google Earth et Google Maps</li>
                        <li><strong>GeoJSON</strong> - Format standard pour les données géographiques</li>
                        <li><strong>GPX</strong> - Format compatible avec OSMAND et autres applications GPS</li>
                    </ul>
                    
                    <h3 class="text-content border-b pb-1 mt-4 mb-3">Notation négative :</h3>
                    <ul class="text-content list-disc pl-5 space-y-1">
                        <li>Pour les nombres négatifs, utilisez le signe "-" (ex: -5)</li>
                        <li>Pour les lettres négatives, utilisez également le signe "-" (ex: -A)</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize dark/light mode
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                document.documentElement.classList.add('dark');
            }
            
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
                if (event.matches) {
                    document.documentElement.classList.add('dark');
                } else {
                    document.documentElement.classList.remove('dark');
                }
            });
            
            // Initialize UI elements
            initUI();
            
            // Set up event listeners
            setupEventListeners();
            
            // Update dynamic grid name initially
            updateDynamicGridName();
        });
        
        function initUI() {
            // Initialize color selection
            document.querySelectorAll('.color-option').forEach(option => {
                option.addEventListener('click', function() {
                    document.querySelectorAll('.color-option').forEach(opt => opt.classList.remove('selected'));
                    this.classList.add('selected');
                    document.getElementById('grid-color').value = this.dataset.color;
                    document.getElementById('grid-color-name').value = this.dataset.name;
                    updateDynamicGridName(); // Update grid name when color changes
                });
            });
            
            // Update range input displays
            const transparencyInput = document.getElementById('transparency');
            const transparencyValue = document.getElementById('transparency-value');
            transparencyValue.textContent = `${transparencyInput.value}%`;
            
            const deviationInput = document.getElementById('deviation');
            const deviationValue = document.getElementById('deviation-value');
            deviationValue.textContent = `${deviationInput.value}°`;
            
            // Reset deviation button
            document.getElementById('reset-deviation').addEventListener('click', function() {
                document.getElementById('deviation').value = 0;
                document.getElementById('deviation-value').textContent = "0°";
                updateDynamicGridName(); // Update grid name when deviation changes
            });
            
            // Handle grid options display
            const gridOptionRadios = document.querySelectorAll('input[name="grid-option"]');
            const defaultGridOptions = document.getElementById('default-grid-options');
            const customGridOptions = document.getElementById('custom-grid-options');
            
            gridOptionRadios.forEach(radio => {
                radio.addEventListener('change', function() {
                    if (this.value === 'default') {
                        defaultGridOptions.classList.remove('hidden');
                        customGridOptions.classList.add('hidden');
                    } else {
                        defaultGridOptions.classList.add('hidden');
                        customGridOptions.classList.remove('hidden');
                    }
                    updateDynamicGridName(); // Update grid name when option changes
                });
            });
            
            // Add listeners to all grid parameters for dynamic name updates
            document.querySelectorAll('.grid-parameter').forEach(element => {
                if (element.type === 'range' || element.type === 'number' || element.type === 'text') {
                    element.addEventListener('input', updateDynamicGridName);
                } else if (element.type === 'radio') {
                    element.addEventListener('change', updateDynamicGridName);
                }
            });
            
            // Initial grid name update
            updateDynamicGridName();
        }
        
        function setupEventListeners() {
            // Range input event listeners
            const transparencyInput = document.getElementById('transparency');
            const transparencyValue = document.getElementById('transparency-value');
            transparencyInput.addEventListener('input', function() {
                transparencyValue.textContent = `${this.value}%`;
            });
            
            const deviationInput = document.getElementById('deviation');
            const deviationValue = document.getElementById('deviation-value');
            deviationInput.addEventListener('input', function() {
                deviationValue.textContent = `${this.value}°`;
                updateDynamicGridName(); // Update grid name when deviation changes
            });
            
            // Coordinate conversion buttons
            document.getElementById('convert-from-decimal').addEventListener('click', convertFromDecimal);
            document.getElementById('convert-from-dms').addEventListener('click', convertFromDMS);
            document.getElementById('convert-from-plus').addEventListener('click', convertFromPlusCode);
            document.getElementById('convert-from-mercator').addEventListener('click', convertFromMercator);
            
            // View on Maps buttons
            document.getElementById('view-on-maps-decimal').addEventListener('click', () => viewOnMaps('decimal'));
            document.getElementById('view-on-maps-dms').addEventListener('click', () => viewOnMaps('dms'));
            document.getElementById('view-on-maps-plus').addEventListener('click', () => viewOnMaps('plus'));
            document.getElementById('view-on-maps-mercator').addEventListener('click', () => viewOnMaps('mercator'));
            
            // Help modal functionality
            document.getElementById('helpBtn').addEventListener('click', function() {
                document.getElementById('help-modal').classList.remove('hidden');
            });
            
            document.getElementById('close-help').addEventListener('click', function() {
                document.getElementById('help-modal').classList.add('hidden');
            });
            
            // Close modal when clicking outside
            document.getElementById('help-modal').addEventListener('click', function(e) {
                if (e.target === this) {
                    this.classList.add('hidden');
                }
            });
            
            // Generate button
            document.getElementById('generate-button').addEventListener('click', generateGrid);
        }
        
        // Function to update the displayed grid name dynamically
        function updateDynamicGridName() {
            // Base name from input
            const baseName = document.getElementById('grid-name-base').value || 'CADO Grid';
            document.getElementById('grid-name').value = baseName;
            
            // Get scale
            const scale = document.getElementById('scale').value || 20;
            
            // Get reference point
            const referencePoint = document.querySelector('input[name="reference-point"]:checked').value;
            
            // Get lettering direction
            const letteringDirection = document.querySelector('input[name="lettering-direction"]:checked').value;
            
            // Get grid bounds
            let gridBounds = "";
            const gridOption = document.querySelector('input[name="grid-option"]:checked').value;
            
            let startCol, startRow, endCol, endRow;
            
            if (gridOption === 'default') {
                const gridType = document.querySelector('input[name="grid-type"]:checked').value;
                
                switch (gridType) {
                    case 'Z26':
                        startRow = 1;
                        endRow = 26;
                        startCol = 'A';
                        endCol = 'Z';
                        gridBounds = "_Z26";
                        break;
                    case 'Z14':
                        startRow = 1;
                        endRow = 14;
                        startCol = 'A';
                        endCol = 'Z';
                        gridBounds = "_Z14";
                        break;
                    case 'Q9':
                        startRow = 1;
                        endRow = 9;
                        startCol = 'A';
                        endCol = 'Q';
                        gridBounds = "_Q9";
                        break;
                    default:
                        gridBounds = "_Z14";
                }
            } else {
                startRow = document.getElementById('start-row').value;
                endRow = document.getElementById('end-row').value;
                startCol = document.getElementById('start-col').value;
                endCol = document.getElementById('end-col').value;
                
                gridBounds = `_${startCol}${startRow}-${endCol}${endRow}`;
            }
            
            // Get deviation
            const deviation = parseInt(document.getElementById('deviation').value) || 0;
            let deviationStr = "";
            if (deviation !== 0) {
                const sign = deviation > 0 ? "+" : "";
                deviationStr = `_${sign}${deviation}°`;
            }
            
            // Get color
            const colorName = document.getElementById('grid-color-name').value;
            
            // Add lettering direction if descending
            let letteringStr = "";
            if (letteringDirection === "descending") {
                letteringStr = "_descendant";
            }
            
            // Build preview name (without origin coordinates which are only available after generation)
            const previewName = `${baseName}_${scale}m_${referencePoint}${letteringStr}${gridBounds}${deviationStr}_${colorName}`;
            
            // Update the displayed name
            document.getElementById('full-grid-name').textContent = previewName;
            
            // Store the name for later use
            document.getElementById('grid-name').value = previewName;
        }
        
        // Coordinate Conversion Functions
        function convertFromDecimal() {
            const decimalInput = document.getElementById('decimal-coords').value.trim();
            if (!decimalInput) {
                showError("Veuillez entrer des coordonnées décimales.");
                return;
            }
            
            try {
                // Parse decimal coordinates
                let [lat, lng] = decimalInput.split(',').map(c => parseFloat(c.trim()));
                
                if (isNaN(lat) || isNaN(lng)) {
                    showError("Format de coordonnées décimales invalide. Utilisez 'lat, lng' (ex: 48.8566, 2.3522)");
                    return;
                }
                
                // Convert to DMS
                const dmsLat = decimalToDMS(lat, 'lat');
                const dmsLng = decimalToDMS(lng, 'lng');
                document.getElementById('dms-coords').value = `${dmsLat} ${dmsLng}`;
                
                // Convert to MERCATOR
                const mercatorX = lngToMercatorX(lng);
                const mercatorY = latToMercatorY(lat);
                document.getElementById('mercator-coords').value = `${mercatorX.toFixed(2)}, ${mercatorY.toFixed(2)}`;
                
                // Try to convert to Plus Code if library is available
                if (typeof OpenLocationCode !== 'undefined') {
                    try {
                        const olc = new OpenLocationCode();
                        const plusCode = olc.encode(lat, lng);
                        document.getElementById('plus-code').value = plusCode;
                    } catch (error) {
                        document.getElementById('plus-code').value = "Erreur de conversion Plus Code";
                    }
                } else {
                    document.getElementById('plus-code').value = "Bibliothèque Plus Code non disponible";
                }
                
                hideError();
            } catch (error) {
                console.error("Error in decimal conversion:", error);
                showError("Erreur de conversion: " + error.message);
            }
        }
        
        function convertFromDMS() {
            const dmsInput = document.getElementById('dms-coords').value.trim();
            if (!dmsInput) {
                showError("Veuillez entrer des coordonnées DMS.");
                return;
            }
            
            try {
                // Parse DMS
                const dmsRegex = /(\d+)°(\d+)'(\d+(\.\d+)?)"([NS])\s+(\d+)°(\d+)'(\d+(\.\d+)?)"([EW])/;
                const match = dmsInput.match(dmsRegex);
                
                if (!match) {
                    showError("Format DMS invalide. Utilisez 'DD°MM'SS.s\"N DD°MM'SS.s\"E'");
                    return;
                }
                
                const degrees1 = parseInt(match[1]);
                const minutes1 = parseInt(match[2]);
                const seconds1 = parseFloat(match[3]);
                const dir1 = match[5];
                
                const degrees2 = parseInt(match[6]);
                const minutes2 = parseInt(match[7]);
                const seconds2 = parseFloat(match[8]);
                const dir2 = match[10];
                
                // Convert to decimal
                let lat = degrees1 + minutes1/60 + seconds1/3600;
                if (dir1 === 'S') lat = -lat;
                
                let lng = degrees2 + minutes2/60 + seconds2/3600;
                if (dir2 === 'W') lng = -lng;
                
                document.getElementById('decimal-coords').value = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
                
                // Convert to MERCATOR
                const mercatorX = lngToMercatorX(lng);
                const mercatorY = latToMercatorY(lat);
                document.getElementById('mercator-coords').value = `${mercatorX.toFixed(2)}, ${mercatorY.toFixed(2)}`;
                
                // Try to convert to Plus Code if library is available
                if (typeof OpenLocationCode !== 'undefined') {
                    try {
                        const olc = new OpenLocationCode();
                        const plusCode = olc.encode(lat, lng);
                        document.getElementById('plus-code').value = plusCode;
                    } catch (error) {
                        document.getElementById('plus-code').value = "Erreur de conversion Plus Code";
                    }
                } else {
                    document.getElementById('plus-code').value = "Bibliothèque Plus Code non disponible";
                }
                
                hideError();
            } catch (error) {
                console.error("Error in DMS conversion:", error);
                showError("Erreur de conversion: " + error.message);
            }
        }
        
        // Fonction de géocodage utilisant l'API Nominatim (OpenStreetMap)
        async function geocodeLocation(locationName) {
            const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(locationName)}&limit=1`;
            
            try {
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.length > 0) {
                    return {
                        latitude: parseFloat(data[0].lat),
                        longitude: parseFloat(data[0].lon)
                    };
                } else {
                    throw new Error(`Impossible de localiser: ${locationName}`);
                }
            } catch (error) {
                throw new Error(`Erreur de géocodage: ${error.message}`);
            }
        }
        
        async function convertFromPlusCode() {
            const plusCodeInput = document.getElementById('plus-code').value.trim();
            if (!plusCodeInput) {
                showError("Veuillez entrer un Plus Code.");
                return;
            }
            
            try {
                // Vérifier si la bibliothèque Open Location Code est disponible
                if (typeof OpenLocationCode === 'undefined') {
                    showError("Bibliothèque Open Location Code non disponible. Utilisez le bouton 'Voir sur Maps'.");
                    return;
                }
                
                const olc = new OpenLocationCode();
                
                // Extraire le code et la localisation si présents
                const plusCodePattern = /([A-Z0-9]{4,8}\+[A-Z0-9]{2,3})/i;
                const match = plusCodeInput.match(plusCodePattern);
                
                if (!match) {
                    showError("Format de Plus Code invalide. Utilisez un format comme '8FW4V75V+' ou 'EW47+QV Paris'.");
                    return;
                }
                
                let fullCode = match[1].toUpperCase();
                
                // Vérifier s'il s'agit d'un code complet ou court
                if (olc.isFullCode(fullCode)) {
                    // Code complet, conversion directe
                    const decoded = olc.decode(fullCode);
                    const lat = decoded.latitudeCenter;
                    const lng = decoded.longitudeCenter;
                    
                    // Mettre à jour les autres formats
                    document.getElementById('decimal-coords').value = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
                    
                    const dmsLat = decimalToDMS(lat, 'lat');
                    const dmsLng = decimalToDMS(lng, 'lng');
                    document.getElementById('dms-coords').value = `${dmsLat} ${dmsLng}`;
                    
                    // Mettre à jour MERCATOR
                    const mercatorX = lngToMercatorX(lng);
                    const mercatorY = latToMercatorY(lat);
                    document.getElementById('mercator-coords').value = `${mercatorX.toFixed(2)}, ${mercatorY.toFixed(2)}`;
                    
                    hideError();
                } else {
                    // Code court, nécessite un contexte géographique
                    // Extraire la partie localisation après le code
                    const locationPart = plusCodeInput.replace(fullCode, '').trim();
                    
                    if (!locationPart) {
                        showError("Ce Plus Code est incomplet. Veuillez ajouter une référence géographique (ex: 'EW47+QV Paris').");
                        return;
                    }
                    
                    // Géocoder la localisation de référence
                    showError("Géocodage en cours...");
                    const referenceLocation = await geocodeLocation(locationPart);
                    
                    // Reconstituer le code complet
                    const recoveredCode = olc.recoverNearest(fullCode, referenceLocation.latitude, referenceLocation.longitude);
                    
                    // Décoder le code complet
                    const decoded = olc.decode(recoveredCode);
                    const lat = decoded.latitudeCenter;
                    const lng = decoded.longitudeCenter;
                    
                    // Mettre à jour tous les formats
                    document.getElementById('plus-code').value = recoveredCode; // Mettre à jour avec le code complet
                    document.getElementById('decimal-coords').value = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
                    
                    const dmsLat = decimalToDMS(lat, 'lat');
                    const dmsLng = decimalToDMS(lng, 'lng');
                    document.getElementById('dms-coords').value = `${dmsLat} ${dmsLng}`;
                    
                    // Mettre à jour MERCATOR
                    const mercatorX = lngToMercatorX(lng);
                    const mercatorY = latToMercatorY(lat);
                    document.getElementById('mercator-coords').value = `${mercatorX.toFixed(2)}, ${mercatorY.toFixed(2)}`;
                    
                    hideError();
                }
                
            } catch (error) {
                console.error("Error in Plus Code conversion:", error);
                showError("Erreur de conversion Plus Code: " + error.message);
            }
        }
        
        function convertFromMercator() {
            const mercatorInput = document.getElementById('mercator-coords').value.trim();
            if (!mercatorInput) {
                showError("Veuillez entrer des coordonnées MERCATOR.");
                return;
            }
            
            try {
                // Parse MERCATOR coordinates (X, Y en mètres)
                let [x, y] = mercatorInput.split(',').map(c => parseFloat(c.trim()));
                
                if (isNaN(x) || isNaN(y)) {
                    showError("Format de coordonnées MERCATOR invalide. Utilisez 'X, Y' en mètres (ex: 263726.05, 6250958.43)");
                    return;
                }
                
                // Convert Web Mercator (EPSG:3857) to WGS84 (EPSG:4326)
                const lat = mercatorYToLat(y);
                const lng = mercatorXToLng(x);
                
                // Update decimal coordinates
                document.getElementById('decimal-coords').value = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
                
                // Convert to DMS
                const dmsLat = decimalToDMS(lat, 'lat');
                const dmsLng = decimalToDMS(lng, 'lng');
                document.getElementById('dms-coords').value = `${dmsLat} ${dmsLng}`;
                
                // Plus Code not available
                document.getElementById('plus-code').value = "Code Plus non disponible";
                
                hideError();
            } catch (error) {
                console.error("Error in MERCATOR conversion:", error);
                showError("Erreur de conversion MERCATOR: " + error.message);
            }
        }
        
        // Fonctions de conversion Web Mercator (EPSG:3857) vers WGS84 (EPSG:4326)
        function mercatorXToLng(x) {
            return x / 20037508.34 * 180;
        }
        
        function mercatorYToLat(y) {
            const lat = y / 20037508.34 * 180;
            return 180 / Math.PI * (2 * Math.atan(Math.exp(lat * Math.PI / 180)) - Math.PI / 2);
        }
        
        // Fonctions de conversion WGS84 vers Web Mercator
        function lngToMercatorX(lng) {
            return lng * 20037508.34 / 180;
        }
        
        function latToMercatorY(lat) {
            const latRad = lat * Math.PI / 180;
            return 20037508.34 / 180 * Math.log(Math.tan((90 + lat) * Math.PI / 360));
        }
        
        function decimalToDMS(coord, type) {
            const absolute = Math.abs(coord);
            const degrees = Math.floor(absolute);
            const minutesNotTruncated = (absolute - degrees) * 60;
            const minutes = Math.floor(minutesNotTruncated);
            const seconds = ((minutesNotTruncated - minutes) * 60).toFixed(1);
            
            let direction = '';
            if (type === 'lat') {
                direction = coord >= 0 ? 'N' : 'S';
            } else {
                direction = coord >= 0 ? 'E' : 'W';
            }
            
            return `${degrees}°${minutes}'${seconds}"${direction}`;
        }
        
        // View on Maps function
        function viewOnMaps(format) {
            let lat, lng;
            
            try {
                if (format === 'decimal') {
                    const decimalInput = document.getElementById('decimal-coords').value.trim();
                    if (!decimalInput) {
                        showError("Veuillez entrer des coordonnées décimales.");
                        return;
                    }
                    
                    [lat, lng] = decimalInput.split(',').map(c => parseFloat(c.trim()));
                    
                    if (isNaN(lat) || isNaN(lng)) {
                        showError("Format de coordonnées décimales invalide.");
                        return;
                    }
                }
                else if (format === 'dms') {
                    const dmsInput = document.getElementById('dms-coords').value.trim();
                    if (!dmsInput) {
                        showError("Veuillez entrer des coordonnées DMS.");
                        return;
                    }
                    
                    // Parse DMS and convert to decimal
                    const dmsRegex = /(\d+)°(\d+)'(\d+(\.\d+)?)"([NS])\s+(\d+)°(\d+)'(\d+(\.\d+)?)"([EW])/;
                    const match = dmsInput.match(dmsRegex);
                    
                    if (!match) {
                        showError("Format DMS invalide.");
                        return;
                    }
                    
                    const degrees1 = parseInt(match[1]);
                    const minutes1 = parseInt(match[2]);
                    const seconds1 = parseFloat(match[3]);
                    const dir1 = match[5];
                    
                    const degrees2 = parseInt(match[6]);
                    const minutes2 = parseInt(match[7]);
                    const seconds2 = parseFloat(match[8]);
                    const dir2 = match[10];
                    
                    lat = degrees1 + minutes1/60 + seconds1/3600;
                    if (dir1 === 'S') lat = -lat;
                    
                    lng = degrees2 + minutes2/60 + seconds2/3600;
                    if (dir2 === 'W') lng = -lng;
                }
                else if (format === 'plus') {
                    const plusCode = document.getElementById('plus-code').value.trim();
                    if (!plusCode) {
                        showError("Veuillez entrer un Plus Code.");
                        return;
                    }
                    
                    // Rediriger vers plus.codes pour une visualisation plus directe
                    window.open(`https://plus.codes/`, '_blank');
                    return;
                }
                else if (format === 'mercator') {
                    const mercatorInput = document.getElementById('mercator-coords').value.trim();
                    if (!mercatorInput) {
                        showError("Veuillez entrer des coordonnées MERCATOR.");
                        return;
                    }
                    
                    // Parse MERCATOR coordinates and convert to decimal
                    let [x, y] = mercatorInput.split(',').map(c => parseFloat(c.trim()));
                    
                    if (isNaN(x) || isNaN(y)) {
                        showError("Format de coordonnées MERCATOR invalide.");
                        return;
                    }
                    
                    // Convert Web Mercator to WGS84
                    lat = mercatorYToLat(y);
                    lng = mercatorXToLng(x);
                }
                
                // Open Google Maps with the coordinates
                window.open(`https://www.google.com/maps?q=${lat},${lng}`, '_blank');
                hideError();
                
            } catch (error) {
                console.error("Error viewing on maps:", error);
                showError("Erreur d'ouverture de Google Maps: " + error.message);
            }
        }
        
        // Grid Generation Functions
        async function generateGrid() {
            // Show loading indicator
            const loadingIndicator = document.getElementById('loading-indicator');
            loadingIndicator.classList.remove('hidden');
            hideError();
            
            try {
                // Get coordinates
                const decimalCoords = document.getElementById('decimal-coords').value.trim();
                if (!decimalCoords) {
                    throw new Error("Veuillez entrer des coordonnées décimales.");
                }
                
                const [lat, lng] = decimalCoords.split(',').map(c => parseFloat(c.trim()));
                if (isNaN(lat) || isNaN(lng)) {
                    throw new Error("Coordonnées décimales invalides.");
                }
                
                // Get grid configuration
                const config = getGridConfiguration(lat, lng);
                
                // Generate grid data
                const gridData = calculateGridData(config);
                
                // Update grid name with origin coordinates
                updateGridNameWithOrigin(config, gridData.a1BottomLeft.coordinates);
                
                // Get color hex value without # for KMZ filename
                const colorHex = config.gridColor.substring(1).toUpperCase();
                
                // Generate output file based on selected format
                const fileFormat = document.querySelector('input[name="file-format"]:checked').value;
                const contentType = document.querySelector('input[name="content-type"]:checked').value;
                
                let outputFile;
                switch (fileFormat) {
                    case 'KML':
                        outputFile = generateKML(config, gridData, colorHex);
                        downloadFile(outputFile, `${config.gridName}.kml`, 'application/vnd.google-earth.kml+xml');
                        break;
                    case 'KMZ':
                        // Pour KMZ, on utilisera les icônes correspondantes à la couleur sélectionnée
                        outputFile = await generateKMZ(config, gridData, colorHex);
                        downloadFile(outputFile, `${config.gridName}.kmz`, 'application/vnd.google-earth.kmz');
                        break;
                    case 'GeoJSON':
                        outputFile = generateGeoJSON(config, gridData);
                        downloadFile(outputFile, `${config.gridName}.geojson`, 'application/geo+json');
                        break;
                    case 'GPX':
                        outputFile = generateGPX(config, gridData);
                        downloadFile(outputFile, `${config.gridName}.gpx`, 'application/gpx+xml');
                        break;
                    default:
                        throw new Error("Format de sortie non supporté.");
                }
                
            } catch (error) {
                console.error("Error generating grid:", error);
                showError(error.message);
            } finally {
                // Hide loading indicator
                loadingIndicator.classList.add('hidden');
            }
        }
        
        // Update grid name with origin coordinates
        function updateGridNameWithOrigin(config, originCoordinates) {
            // Get the current grid name (without origin)
            const currentName = document.getElementById('grid-name').value;
            
            // Format origin coordinates
            const originLat = originCoordinates[1].toFixed(8);
            const originLng = originCoordinates[0].toFixed(8);
            const originStr = `_origine=${originLat},${originLng}`;
            
            // Build full name with origin coordinates
            const fullName = `${currentName}${originStr}`;
            
            // Update config with new name
            config.gridName = fullName;
            
            // Update displayed name
            document.getElementById('full-grid-name').textContent = fullName;
        }
        
        function getGridConfiguration(lat, lng) {
            // Get all configuration values from UI
            const scale = parseFloat(document.getElementById('scale').value);
            const gridColor = document.getElementById('grid-color').value;
            const colorName = document.getElementById('grid-color-name').value;
            const transparency = parseInt(document.getElementById('transparency').value);
            const gridName = document.getElementById('grid-name').value || 'CADO Grid';
            const deviation = parseInt(document.getElementById('deviation').value);
            const labelSize = parseFloat(document.getElementById('label-size').value);
            const iconSize = parseFloat(document.getElementById('icon-size').value || 2);
            
            // Determine text outline color based on the selected color
            let needsDarkOutline = false;
            
            // Simplified direct case statement for outline color determination
            switch(colorName) {
                case 'white':
                case 'orange':
                case 'yellow':
                    needsDarkOutline = true; // Contour noir
                    break;
                case 'red':
                case 'green':
                case 'blue':
                case 'violet':
                case 'black':
                case 'brown':
                case 'gray':
                    needsDarkOutline = false; // Contour blanc
                    break;
                default:
                    // Default to black outline for light colors, white for dark
                    needsDarkOutline = true;
            }
            
            // Reference point
            const referencePoint = document.querySelector('input[name="reference-point"]:checked').value;
            
            // Lettering direction
            const letteringDirection = document.querySelector('input[name="lettering-direction"]:checked').value;
            
            // Grid type
            const gridOption = document.querySelector('input[name="grid-option"]:checked').value;
            
            let startRow, endRow, startCol, endCol;
            
            if (gridOption === 'default') {
                const gridType = document.querySelector('input[name="grid-type"]:checked').value;
                
                switch (gridType) {
                    case 'Z26':
                        startRow = 1;
                        endRow = 26;
                        startCol = 'A';
                        endCol = 'Z';
                        break;
                    case 'Z14':
                        startRow = 1;
                        endRow = 14;
                        startCol = 'A';
                        endCol = 'Z';
                        break;
                    case 'Q9':
                        startRow = 1;
                        endRow = 9;
                        startCol = 'A';
                        endCol = 'Q';
                        break;
                    default:
                        startRow = 1;
                        endRow = 14;
                        startCol = 'A';
                        endCol = 'Z';
                }
            } else {
                startRow = parseInt(document.getElementById('start-row').value);
                endRow = parseInt(document.getElementById('end-row').value);
                startCol = document.getElementById('start-col').value;
                endCol = document.getElementById('end-col').value;
            }
            
            // Output format options
            const contentType = document.querySelector('input[name="content-type"]:checked').value;
            const includeGrid = ['grid-only', 'grid-points'].includes(contentType);
            const includePoints = ['points-only', 'grid-points'].includes(contentType);
            
            return {
                latitude: lat,
                longitude: lng,
                scale,
                gridColor,
                colorName,
                colorOpacity: (100 - transparency) / 100,
                gridName,
                deviation,
                labelSize,
                iconSize,
                needsDarkOutline,
                referencePoint,
                letteringDirection,
                startRow,
                endRow,
                startCol,
                endCol,
                includeGrid,
                includePoints,
                contentType,
                outputFormat: document.querySelector('input[name="file-format"]:checked').value
            };
        }
        
        // Generate array of row/column indices properly skipping zero
        function generateIndices(start, end) {
            const indices = [];
            if (start <= end) {
                for (let i = start; i <= end; i++) {
                    if (i !== 0) indices.push(i);
                }
            } else {
                for (let i = start; i >= end; i--) {
                    if (i !== 0) indices.push(i);
                }
            }
            return indices;
        }
        
        // Fonction ajustant le déplacement pour tenir compte de l'absence de ligne/colonne 0
        function adjustedOffset(index, referenceIndex, scale) {
            // Si les indices sont du même signe (tous deux positifs ou tous deux négatifs)
            if ((index > 0 && referenceIndex > 0) || (index < 0 && referenceIndex < 0)) {
                return (index - referenceIndex) * scale;
            }
            // Si l'index est négatif et la référence positive, on saute le 0
            else if (index < 0 && referenceIndex > 0) {
                return (index - referenceIndex + 1) * scale; // +1 pour sauter le 0
            }
            // Si l'index est positif et la référence négative, on saute le 0
            else if (index > 0 && referenceIndex < 0) {
                return (index - referenceIndex - 1) * scale; // -1 pour sauter le 0
            }
            // Si l'un des indices est zéro (ne devrait pas arriver)
            else {
                return (index - referenceIndex) * scale;
            }
        }
        
        // Calcule la distance physique totale exacte entre deux indices, en tenant compte du saut du zéro
        function getTotalGridDistance(min, max, scale) {
            if (min >= 0 && max >= 0) {
                // Tous deux positifs
                return (max - min) * scale;
            } else if (min <= 0 && max <= 0) {
                // Tous deux négatifs
                return (min - max) * scale;
            } else {
                // L'une positive, l'autre négative, on saute le zéro
                return ((Math.abs(min) + Math.abs(max) - 1) * scale);
            }
        }
        
        function calculateGridData(config) {
            // Determine if orientation is ascending (numbers increase southward to northward)
            const isAscending = config.letteringDirection === 'ascending';
            
            // Get visible row and column indices (skipping zero)
            const rowIndices = generateIndices(config.startRow, config.endRow);
            
            // Get column indices (skipping zero)
            const startColNum = letterToNumber(config.startCol);
            const endColNum = letterToNumber(config.endCol);
            
            // Create column indices properly excluding zero
            const colIndices = [];
            if (startColNum <= endColNum) {
                for (let i = startColNum; i <= endColNum; i++) {
                    if (i !== 0) colIndices.push(i);  // Skip column 0
                }
            } else {
                for (let i = startColNum; i >= endColNum; i--) {
                    if (i !== 0) colIndices.push(i);  // Skip column 0
                }
            }
            
            // Number of rows and columns in the visible grid
            const numRows = rowIndices.length;
            const numCols = colIndices.length;
            
            // Conversion factors for meters to coordinates
            const metersToLat = (meters) => meters / 111320;
            const metersToLng = (meters, lat) => meters / (111320 * Math.cos(lat * Math.PI / 180));
            
            // Determine position of the A1 cell corner based on reference point
            let a1CornerLat, a1CornerLng;
            
            if (config.referencePoint === 'origin') {
                // If reference point is "origin", coordinates directly represent A1 corner
                a1CornerLat = config.latitude;
                a1CornerLng = config.longitude;
            } 
            else if (config.referencePoint === 'center') {
                // We need to calculate the physical center position of the grid, taking into account zero-skipping
                // Determine min/max of our grid for better center calculation
                const minRow = Math.min(...rowIndices);
                const maxRow = Math.max(...rowIndices);
                const minCol = Math.min(...colIndices);
                const maxCol = Math.max(...colIndices);
                
                // Reference values for A1 position
                const referenceColA = letterToNumber('A');
                const referenceRow1 = 1;
                
                // Calculate grid dimensions in meters
                // For proper centering, calculate total physical width and height, accounting for zero-skipping
                const gridWidthMeters = getTotalGridDistance(minCol, maxCol, config.scale) + config.scale; // +scale for the extra edge
                const gridHeightMeters = getTotalGridDistance(minRow, maxRow, config.scale) + config.scale; // +scale for the extra edge
                
                // Calculate distance from center to A1 reference position
                let midPointCol = minCol + (maxCol - minCol) / 2;
                let midPointRow = minRow + (maxRow - minRow) / 2;
                
                // Calculate exact offset from center to A1
                const a1RelX = -(gridWidthMeters / 2) + adjustedOffset(referenceColA, minCol, config.scale);
                const a1RelY = isAscending ? 
                    -(gridHeightMeters / 2) + adjustedOffset(referenceRow1, minRow, config.scale) :
                    (gridHeightMeters / 2) - adjustedOffset(referenceRow1, minRow, config.scale);
                
                // Convert to coordinates
                a1CornerLng = config.longitude + metersToLng(a1RelX, config.latitude);
                a1CornerLat = config.latitude + metersToLat(a1RelY);
            }
            
            // Apply deviation/rotation if needed
            let a1BottomLeftCoordinates;
            const deviationRad = -((config.deviation * Math.PI) / 180); // Negative to reverse rotation direction
            
            if (config.deviation !== 0) {
                // Since origin is A1, we rotate around config.latitude/longitude
                if (config.referencePoint === 'origin') {
                    // A1 is already at the reference point, so no rotation needed for A1
                    a1BottomLeftCoordinates = [a1CornerLng, a1CornerLat];
                } else {
                    // For center reference, we need to rotate A1 around center
                    const dLng = a1CornerLng - config.longitude;
                    const dLat = a1CornerLat - config.latitude;
                    
                    // Convert to meters for rotation
                    const x = dLng * 111320 * Math.cos(config.latitude * Math.PI / 180);
                    const y = dLat * 111320;
                    
                    // Rotate (using negative deviationRad for clockwise rotation with positive values)
                    const rotX = x * Math.cos(deviationRad) - y * Math.sin(deviationRad);
                    const rotY = x * Math.sin(deviationRad) + y * Math.cos(deviationRad);
                    
                    // Convert back to coordinates
                    const rotLng = config.longitude + metersToLng(rotX, config.latitude);
                    const rotLat = config.latitude + metersToLat(rotY);
                    
                    a1BottomLeftCoordinates = [rotLng, rotLat];
                }
            } else {
                a1BottomLeftCoordinates = [a1CornerLng, a1CornerLat];
            }
            
            // Generate reference circle around the reference point
            const circleRadius = config.scale / 8;
            const circlePoints = generateCirclePoints(config.longitude, config.latitude, circleRadius, 36);
            
            // Generate horizontal and vertical grid lines
            const horizontalLines = [];
            const verticalLines = [];
            
            // Référence pour les calculs d'offset
            const referenceColA = letterToNumber('A');
            const referenceRow1 = 1;
            
            // Generate horizontal lines
            // Nous générons numRows+1 lignes horizontales pour créer la grille complète
            for (let rowIdx = 0; rowIdx <= numRows; rowIdx++) {
                const points = [];
                let lineName = "";
                
                // Get row index for labeling, sans inclure de ligne zéro
                if (rowIdx < numRows) {
                    lineName = rowIndices[rowIdx].toString();
                }
                
                // Calculate row offset with adjusted position calculation
                let rowOffset;
                if (rowIdx < numRows) {
                    if (isAscending) {
                        // Use the adjustedOffset function to correctly handle zero-crossing
                        rowOffset = adjustedOffset(rowIndices[rowIdx], referenceRow1, config.scale);
                    } else {
                        rowOffset = -adjustedOffset(rowIndices[rowIdx], referenceRow1, config.scale);
                    }
                } else {
                    // For the last line (edge of grid)
                    const lastRow = rowIndices[numRows - 1];
                    if (isAscending) {
                        rowOffset = adjustedOffset(lastRow, referenceRow1, config.scale) + config.scale;
                    } else {
                        rowOffset = -adjustedOffset(lastRow, referenceRow1, config.scale) - config.scale;
                    }
                }
                
                // Generate points for this horizontal line
                for (let colIdx = 0; colIdx <= numCols; colIdx++) {
                    // Calculate column offset with adjusted position
                    const colOffset = colIdx < numCols 
                        ? adjustedOffset(colIndices[colIdx], referenceColA, config.scale)
                        : adjustedOffset(colIndices[numCols - 1], referenceColA, config.scale) + config.scale;
                    
                    // Calculate point with no rotation
                    let pointLng = a1CornerLng + metersToLng(colOffset, a1CornerLat);
                    let pointLat = a1CornerLat + metersToLat(rowOffset);
                    
                    // Apply rotation if needed
                    if (config.deviation !== 0) {
                        // Calculate offset from reference point
                        let refPoint;
                        if (config.referencePoint === 'origin') {
                            refPoint = [a1CornerLng, a1CornerLat]; // Rotate around A1
                        } else {
                            refPoint = [config.longitude, config.latitude]; // Rotate around center
                        }
                        
                        const dx = pointLng - refPoint[0];
                        const dy = pointLat - refPoint[1];
                        
                        // Convert to meters
                        const x = dx * 111320 * Math.cos(refPoint[1] * Math.PI / 180);
                        const y = dy * 111320;
                        
                        // Rotate (using negative deviationRad for clockwise rotation with positive values)
                        const rotX = x * Math.cos(deviationRad) - y * Math.sin(deviationRad);
                        const rotY = x * Math.sin(deviationRad) + y * Math.cos(deviationRad);
                        
                        // Convert back to coordinates
                        pointLng = refPoint[0] + metersToLng(rotX, refPoint[1]);
                        pointLat = refPoint[1] + metersToLat(rotY);
                    }
                    
                    points.push([pointLng, pointLat]);
                }
                
                horizontalLines.push({
                    name: lineName,
                    points: points
                });
            }
            
            // Generate vertical lines
            // Nous générons numCols+1 lignes verticales pour créer la grille complète
            for (let colIdx = 0; colIdx <= numCols; colIdx++) {
                const points = [];
                let lineName = "";
                
                // Get column index for labeling, sans inclure de colonne zéro
                if (colIdx < numCols) {
                    lineName = numberToLetter(colIndices[colIdx]);
                }
                
                // Calculate column offset with adjusted position
                const colOffset = colIdx < numCols 
                    ? adjustedOffset(colIndices[colIdx], referenceColA, config.scale)
                    : adjustedOffset(colIndices[numCols - 1], referenceColA, config.scale) + config.scale;
                
                // Generate points for this vertical line
                for (let rowIdx = 0; rowIdx <= numRows; rowIdx++) {
                    // Calculate row offset with adjusted position
                    let rowOffset;
                    if (rowIdx < numRows) {
                        if (isAscending) {
                            rowOffset = adjustedOffset(rowIndices[rowIdx], referenceRow1, config.scale);
                        } else {
                            rowOffset = -adjustedOffset(rowIndices[rowIdx], referenceRow1, config.scale);
                        }
                    } else {
                        // For the last point (edge of grid)
                        const lastRow = rowIndices[numRows - 1];
                        if (isAscending) {
                            rowOffset = adjustedOffset(lastRow, referenceRow1, config.scale) + config.scale;
                        } else {
                            rowOffset = -adjustedOffset(lastRow, referenceRow1, config.scale) - config.scale;
                        }
                    }
                    
                    // Calculate point with no rotation
                    let pointLng = a1CornerLng + metersToLng(colOffset, a1CornerLat);
                    let pointLat = a1CornerLat + metersToLat(rowOffset);
                    
                    // Apply rotation if needed
                    if (config.deviation !== 0) {
                        // Calculate offset from reference point
                        let refPoint;
                        if (config.referencePoint === 'origin') {
                            refPoint = [a1CornerLng, a1CornerLat]; // Rotate around A1
                        } else {
                            refPoint = [config.longitude, config.latitude]; // Rotate around center
                        }
                        
                        const dx = pointLng - refPoint[0];
                        const dy = pointLat - refPoint[1];
                        
                        // Convert to meters
                        const x = dx * 111320 * Math.cos(refPoint[1] * Math.PI / 180);
                        const y = dy * 111320;
                        
                        // Rotate (using negative deviationRad for clockwise rotation with positive values)
                        const rotX = x * Math.cos(deviationRad) - y * Math.sin(deviationRad);
                        const rotY = x * Math.sin(deviationRad) + y * Math.cos(deviationRad);
                        
                        // Convert back to coordinates
                        pointLng = refPoint[0] + metersToLng(rotX, refPoint[1]);
                        pointLat = refPoint[1] + metersToLat(rotY);
                    }
                    
                    points.push([pointLng, pointLat]);
                }
                
                verticalLines.push({
                    name: lineName,
                    points: points
                });
            }
            
            // Generate center points for each cell
            const points = [];
            
            for (let rowIdx = 0; rowIdx < numRows; rowIdx++) {
                const rowNum = rowIndices[rowIdx];
                
                for (let colIdx = 0; colIdx < numCols; colIdx++) {
                    const colNum = colIndices[colIdx];
                    const colName = numberToLetter(colNum);
                    
                    // Calculate cell center position using adjusted offset + half a cell
                    const colOffset = adjustedOffset(colNum, referenceColA, config.scale) + (config.scale / 2);
                    let rowOffset;
                    if (isAscending) {
                        rowOffset = adjustedOffset(rowNum, referenceRow1, config.scale) + (config.scale / 2);
                    } else {
                        rowOffset = -adjustedOffset(rowNum, referenceRow1, config.scale) - (config.scale / 2);
                    }
                    
                    // Calculate point with no rotation
                    let pointLng = a1CornerLng + metersToLng(colOffset, a1CornerLat);
                    let pointLat = a1CornerLat + metersToLat(rowOffset);
                    
                    // Apply rotation if needed
                    if (config.deviation !== 0) {
                        // Calculate offset from reference point
                        let refPoint;
                        if (config.referencePoint === 'origin') {
                            refPoint = [a1CornerLng, a1CornerLat]; // Rotate around A1
                        } else {
                            refPoint = [config.longitude, config.latitude]; // Rotate around center
                        }
                        
                        const dx = pointLng - refPoint[0];
                        const dy = pointLat - refPoint[1];
                        
                        // Convert to meters
                        const x = dx * 111320 * Math.cos(refPoint[1] * Math.PI / 180);
                        const y = dy * 111320;
                        
                        // Rotate (using negative deviationRad for clockwise rotation with positive values)
                        const rotX = x * Math.cos(deviationRad) - y * Math.sin(deviationRad);
                        const rotY = x * Math.sin(deviationRad) + y * Math.cos(deviationRad);
                        
                        // Convert back to coordinates
                        pointLng = refPoint[0] + metersToLng(rotX, refPoint[1]);
                        pointLat = refPoint[1] + metersToLat(rotY);
                    }
                    
                    // Create the cell name
                    const cellName = `${colName}${rowNum}`;
                    
                    points.push({
                        name: cellName,
                        coordinates: [pointLng, pointLat]
                    });
                }
            }
            
            // Format A1 bottom-left coordinates for display
            const displayLat = a1BottomLeftCoordinates[1].toFixed(8);
            const displayLng = a1BottomLeftCoordinates[0].toFixed(8);
            const a1BottomLeftName = `A1 (${displayLat}, ${displayLng})`;
            
            return {
                horizontalLines,
                verticalLines,
                points,
                referencePoint: {
                    coordinates: [config.longitude, config.latitude],
                    circle: circlePoints
                },
                a1BottomLeft: {
                    name: a1BottomLeftName,
                    coordinates: a1BottomLeftCoordinates
                }
            };
        }
        
        // Generate circle points around a center
        function generateCirclePoints(centerLng, centerLat, radiusInMeters, numPoints) {
            const points = [];
            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const dx = radiusInMeters * Math.cos(angle);
                const dy = radiusInMeters * Math.sin(angle);
                
                const pointLng = centerLng + dx / (111320 * Math.cos(centerLat * Math.PI / 180));
                const pointLat = centerLat + dy / 111320;
                
                points.push([pointLng, pointLat]);
            }
            // Close the circle
            points.push(points[0]);
            
            return points;
        }
        
        // Utility Functions
        function letterToNumber(letter) {
            // Handle negative column indices (e.g., "-A")
            if (letter.startsWith('-')) {
                return -letterToNumber(letter.substring(1));
            }
            
            let result = 0;
            const letters = letter.toUpperCase();
            
            for (let i = 0; i < letters.length; i++) {
                result = result * 26 + (letters.charCodeAt(i) - 64);
            }
            
            return result;
        }
        
        function numberToLetter(num) {
            // Handle negative indices
            if (num < 0) {
                return '-' + numberToLetter(-num);
            }
            
            // CORRECTION: Explicitement gérer le cas 0
            if (num === 0) {
                return ''; // Retourner une chaîne vide ou une valeur spéciale pour l'indice 0
            }
            
            let result = '';
            let n = num;
            
            while (n > 0) {
                const remainder = (n - 1) % 26;
                result = String.fromCharCode(65 + remainder) + result;
                n = Math.floor((n - 1) / 26);
            }
            
            return result;
        }
        
        // Fonction pour convertir base64 en Blob
        function base64ToBlob(base64, mimeType) {
            const byteString = atob(base64);
            const ab = new ArrayBuffer(byteString.length);
            const ia = new Uint8Array(ab);
            
            for (let i = 0; i < byteString.length; i++) {
                ia[i] = byteString.charCodeAt(i);
            }
            
            return new Blob([ab], { type: mimeType });
        }
        
        // Output Format Generators
        function generateKML(config, gridData, colorHex) {
            // Déterminer le comportement en fonction du format de sortie
            const isKMZ = config.outputFormat === 'KMZ';
            
            // Pour KMZ : Icônes visibles (taille définie par l'utilisateur), étiquettes masquées
            // Pour KML/autres : Pas d'icônes, étiquettes visibles (taille définie par l'utilisateur)
            const pointIconScale = isKMZ ? config.iconSize : 0; // 0 = icône invisible pour KML
            const labelScale = isKMZ ? 0 : config.labelSize; // 0 = étiquette invisible pour KMZ
            
            // Couleur du texte basée sur la couleur de la grille
            const textColor = rgbToKmlColor(config.gridColor, 1.0);
            const textOutlineColor = config.needsDarkOutline ? "ff000000" : "ffffffff"; // black or white
            
            // Format coordinates for origin label
            const displayLat = gridData.a1BottomLeft.coordinates[1].toFixed(8);
            const displayLng = gridData.a1BottomLeft.coordinates[0].toFixed(8);
            const originLabel = `Origine : ${displayLat}, ${displayLng}`;
            
            // KML format with improved styling
            let kml = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>${config.gridName}</name>
    <description>Générateur de carroyage CADO</description>
    
    <!-- Style for grid lines -->
    <Style id="gridLineStyle">
      <LineStyle>
        <color>${rgbToKmlColor(config.gridColor, config.colorOpacity)}</color>
        <width>2</width>
      </LineStyle>
    </Style>`;
            
            // Style pour le point d'origine - toujours avec texte visible, jamais d'icône
            kml += `
    <Style id="originPointStyle">
      <IconStyle>
        <scale>0</scale>
      </IconStyle>
      <LabelStyle>
        <color>${textColor}</color>
        <colorMode>normal</colorMode>
        <scale>${config.labelSize}</scale>
      </LabelStyle>
    </Style>`;
            
            // Ajouter des styles pour chaque point dans le carroyage
            if (config.includePoints) {
                gridData.points.forEach(point => {
                    const styleId = `point_${point.name}_style`;
                    
                    // Le style varie en fonction du format
                    kml += `
    <Style id="${styleId}">`;
                    
                    // Pour KMZ uniquement, ajouter la référence à l'icône
                    if (isKMZ) {
                        kml += `
      <IconStyle>
        <scale>${pointIconScale}</scale>
        <Icon>
          <href>icons/${point.name}.png</href>
        </Icon>
        <hotSpot x="0.5" y="0.5" xunits="fraction" yunits="fraction"/>
      </IconStyle>`;
                    } else {
                        // Pour les formats autres que KMZ, pas d'icône
                        kml += `
      <IconStyle>
        <scale>0</scale>
      </IconStyle>`;
                    }
                    
                    // Ajouter le style pour l'étiquette (visible ou non selon le format)
                    kml += `
      <LabelStyle>
        <color>${textColor}</color>
        <colorMode>normal</colorMode>
        <scale>${labelScale}</scale>
      </LabelStyle>
    </Style>`;
                });
            }
            
            // Add reference circle style
            kml += `
    <Style id="referenceCircleStyle">
      <LineStyle>
        <color>ff00ffff</color>
        <width>2</width>
      </LineStyle>
      <PolyStyle>
        <color>3300ffff</color>
        <fill>1</fill>
        <outline>1</outline>
      </PolyStyle>
    </Style>
    
    <Folder>
      <name>Carroyage</name>`;
            
            // Add horizontal lines
            if (config.includeGrid) {
                kml += `
      <Folder>
        <name>Lignes horizontales</name>`;
                gridData.horizontalLines.forEach(line => {
                    kml += `
        <Placemark>
          <name>Ligne ${line.name}</name>
          <styleUrl>#gridLineStyle</styleUrl>
          <LineString>
            <tessellate>1</tessellate>
            <coordinates>`;
                    line.points.forEach(point => {
                        kml += `${point[0]},${point[1]},0 `;
                    });
                    kml += `</coordinates>
          </LineString>
        </Placemark>`;
                });
                kml += `
      </Folder>`;
                
                // Add vertical lines
                kml += `
      <Folder>
        <name>Lignes verticales</name>`;
                gridData.verticalLines.forEach(line => {
                    kml += `
        <Placemark>
          <name>Ligne ${line.name}</name>
          <styleUrl>#gridLineStyle</styleUrl>
          <LineString>
            <tessellate>1</tessellate>
            <coordinates>`;
                    line.points.forEach(point => {
                        kml += `${point[0]},${point[1]},0 `;
                    });
                    kml += `</coordinates>
          </LineString>
        </Placemark>`;
                });
                kml += `
      </Folder>`;
            }
            
            // Add center points with appropriate styling
            if (config.includePoints) {
                kml += `
      <Folder>
        <name>Points centraux</name>`;
                gridData.points.forEach(point => {
                    const styleId = `point_${point.name}_style`;
                    
                    kml += `
        <Placemark>
          <name>${point.name}</name>
          <styleUrl>#${styleId}</styleUrl>
          <Point>
            <coordinates>${point.coordinates[0]},${point.coordinates[1]},0</coordinates>
          </Point>
        </Placemark>`;
                });
                kml += `
      </Folder>`;
            }
            
            // Add A1 bottom-left point and reference circle (always included)
            kml += `
      <Folder>
        <name>Points de référence</name>
        <!-- Origin point (A1 bottom-left) -->
        <Placemark>
          <name>${originLabel}</name>
          <styleUrl>#originPointStyle</styleUrl>
          <Point>
            <coordinates>${gridData.a1BottomLeft.coordinates[0]},${gridData.a1BottomLeft.coordinates[1]},0</coordinates>
          </Point>
        </Placemark>
        
        <!-- Reference point circle -->
        <Placemark>
          <name>Cercle de référence</name>
          <styleUrl>#referenceCircleStyle</styleUrl>
          <Polygon>
            <outerBoundaryIs>
              <LinearRing>
                <coordinates>`;
            
            gridData.referencePoint.circle.forEach(point => {
                kml += `${point[0]},${point[1]},0 `;
            });
            
            kml += `</coordinates>
              </LinearRing>
            </outerBoundaryIs>
          </Polygon>
        </Placemark>
      </Folder>`;
            
            kml += `
    </Folder>
  </Document>
</kml>`;
            
            return kml;
        }
        
        async function generateKMZ(config, gridData, colorHex) {
            // Vérification et logging pour débugger
            console.log(`Génération du KMZ avec la couleur ${colorHex}`);
            console.log(`État des dictionnaires d'icônes:`, Object.keys(iconDictionaries));
            
            // Récupérer les données d'icônes pour cette couleur
            const iconDict = iconDictionaries[colorHex] || {};
            
            // Vérifier si le dictionnaire contient des données
            if (Object.keys(iconDict).length === 0) {
                console.warn(`Aucune icône disponible pour la couleur ${colorHex}`);
                // Essayer de créer manuellement les icônes
                await initIconDictionaries();
            }
            
            // Générer des icônes de base pour tous les points si nécessaire
            let hasIcons = Object.keys(iconDict).length > 0;
            if (!hasIcons) {
                console.log("Aucune icône disponible, création d'icônes de base...");
                
                // Créer un dictionnaire d'icônes de base
                try {
                    // Utiliser une seule icône par défaut pour tous les points
                    const defaultIcon = "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MEVBMTczNDg3QzA5MTFFNjk3ODM5NjQyRjE2RjA3QTkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MEVBMTczNDk3QzA5MTFFNjk3ODM5NjQyRjE2RjA3QTkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDowRUExNzM0NjdDMDkxMUU2OTc4Mzk2NDJGMTZGMDdBOSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDowRUExNzM0NzdDMDkxMUU2OTc4Mzk2NDJGMTZGMDdBOSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PjjUmssAAAGISURBVHjapFPNSkJBFJ4x85dQK8w2QQuLIBQXrXoFeoCiNwgkCFpEz9CiJailCG0ijJZBhFlkUItMKpI2/qbt1LlXr+YgLeqDj3OY75w535n5OEIIIX8PMbXCmImTZ39iuVxOxJkYw4SLczOmNJ/PGzkhM5nM9vb2HmvAUjwej6FJoVBgeDSh0sGgCZm2XC4/SqUSTySS1JeWl+n6+jpF20pYNp1OC2xpsFxXW8/ODoVCerleX4j4gkGZgIJyHGT7crlsIpEI2draKlUqFSoQi8UoBlhY3TsEoDEwMECZEoglk4mjgKos29EK2ZXfDwKxzFyhEJAkhQv11nGsP0Mj9XrdBHx3/SM7OzvZzc1N51AwGH2/vf1+vLk5SQ8P1x2ut5vN9mIwaAi38abe+Xyenp+fLwQQa2dnh77d359H+vqigUjEPR0OT3hMpnehu/vR4Qro6OgwAdhWYFpbWxvx8nJsZG5ufGphgXlmZhLtkMmI98bGzWbx2Cy/C7rHp6cYPDmZsLS0yAwNDTFWV1e5Q3UXLIjtv/8FeQcT4jxo4QcsPQAAAABJRU5ErkJggg==";
                    
                    // Pour chaque point de la grille, créer une icône
                    for (const point of gridData.points) {
                        iconDict[point.name] = defaultIcon;
                    }
                    
                    console.log(`${Object.keys(iconDict).length} icônes par défaut créées`);
                    hasIcons = true;
                } catch (error) {
                    console.error("Erreur lors de la création d'icônes par défaut:", error);
                }
            }
            
            try {
                // Generate KML content
                const kmlContent = generateKML(config, gridData, colorHex);
                
                // Create zip archive
                const zip = new JSZip();
                
                // Ajouter le fichier KML principal
                zip.file("doc.kml", kmlContent);
                
                // Créer le dossier icons
                const iconsFolder = zip.folder("icons");
                
                // Compter les icônes ajoutées
                let iconsAdded = 0;
                
                // Ajouter les icônes comme fichiers PNG individuels
                if (config.includePoints) {
                    for (const point of gridData.points) {
                        const iconBase64 = iconDict[point.name];
                        
                        if (iconBase64) {
                            try {
                                // Vérifier si la chaîne base64 a un préfixe
                                let cleanBase64 = iconBase64;
                                if (iconBase64.startsWith("data:image/png;base64,")) {
                                    cleanBase64 = iconBase64.replace("data:image/png;base64,", "");
                                    console.log(`Suppression du préfixe data:image/png;base64, pour ${point.name}`);
                                }
                                
                                // Ajouter directement la chaîne base64 avec l'option base64: true
                                iconsFolder.file(`${point.name}.png`, cleanBase64, { base64: true });
                                iconsAdded++;
                                
                                // Ajouter aussi un fichier test.png pour vérifier
                                if (point.name === "A1") {
                                    iconsFolder.file("test.png", cleanBase64, { base64: true });
                                    console.log("Fichier test.png ajouté");
                                }
                            } catch (iconError) {
                                console.error(`Erreur lors de l'ajout de l'icône ${point.name}:`, iconError);
                            }
                        } else {
                            console.warn(`Aucune icône disponible pour ${point.name}`);
                        }
                    }
                }
                
                console.log(`${iconsAdded} icônes ajoutées au fichier KMZ`);
                
                // Ajouter un fichier texte pour le debugging
                iconsFolder.file("debug.txt", `Couleur: ${colorHex}\nIcônes disponibles: ${Object.keys(iconDict).length}\nIcônes ajoutées: ${iconsAdded}`);
                
                // Utiliser un exemple d'icône statique pour le test si aucune icône n'a été ajoutée
                if (iconsAdded === 0) {
                    const testIconBase64 = "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAIVSURBVDjLjZPLaxNRFIerCoLgQgQXbmqhgmJcFYJYFxGxO/cuXPgHFKKCUF3pqiLIFCtEkkDaiGlMY2JiHqYvkzR5NJm0eaSZZpJMo6TpJJlrZiRDfMxiZuHjHu79fd+5h+OGhobyuDj3TL5dL792VhIdr8TxdNnDbVleSSQ1ii5lmYodjx+c4/5qYn+wnD7PpVWbph0TrXOezTPD7RhyLLOPrptBVgrheJRQMIhW0x3KLMsik8mg1WqxbLVaCIIgxXEcNE2LUyQFGc/dwA0diKIoUQ01+cHxoigmJUmCDgeUwpGm4vpFNCot0EvX3O7GGzQnLwPHsB9QMmxIG7zJh0nUlTdARdmQV2OxGDRNgzzPQ5ZlxzfztWMBtYklrMefwp7XpUQiwZIPBgNJo9HAeDzehvnCMTYmL0IqXYVhGFBV1dEkDzDLMqRHJyDmryw7QRB+Nxk3DCO+QTJu26STmZpzg511RkYE51SmvQkcH3B5XEwqzGz48BZlvHwSoudJyvY3wd9+f/FuzKmCjy9RJq8Cgweoua/0NaL1+eLrXElWTJyyPzEkoMt7wAjgk3fBU7HfUg6QZxzXYdlmQ7bDwsA5wRXQN8xZyVsryiRVOjlBP2OK/EVACNAf0uXMB5xR2Iv3jh+4LwOdqwHKgX6GT3VH2Kb7cB8lf3LA/wH/hv5/f/tuCDwRQxUAAAAASUVORK5CYII=";
                    iconsFolder.file("default.png", testIconBase64, { base64: true });
                    console.log("Ajout d'une icône par défaut pour le test");
                }
                
                // Generate KMZ file
                const kmzBlob = await zip.generateAsync({
                    type: "blob", 
                    compression: "DEFLATE",
                    compressionOptions: {
                        level: 9
                    }
                });
                
                console.log("KMZ généré avec succès", kmzBlob.size, "octets");
                return kmzBlob;
            } catch (error) {
                console.error("Erreur lors de la génération du KMZ:", error);
                showError("Erreur lors de la génération du KMZ: " + error.message);
                
                // Créer un KMZ de secours sans les images
                const zip = new JSZip();
                zip.file("doc.kml", generateKML(config, gridData, colorHex));
                zip.file("README.txt", "Erreur lors de l'inclusion des icônes. Le fichier KMZ contient uniquement le KML sans les icônes.");
                
                const kmzBlob = await zip.generateAsync({type: "blob"});
                return kmzBlob;
            }
        }
        
        function generateGeoJSON(config, gridData) {
            const geoJson = {
                "type": "FeatureCollection",
                "name": config.gridName,
                "features": []
            };
            
            // Add horizontal lines
            if (config.includeGrid) {
                gridData.horizontalLines.forEach(line => {
                    const lineFeature = {
                        "type": "Feature",
                        "properties": {
                            "name": `Ligne ${line.name}`,
                            "type": "horizontal",
                            "color": config.gridColor,
                            "opacity": config.colorOpacity
                        },
                        "geometry": {
                            "type": "LineString",
                            "coordinates": line.points
                        }
                    };
                    geoJson.features.push(lineFeature);
                });
                
                // Add vertical lines
                gridData.verticalLines.forEach(line => {
                    const lineFeature = {
                        "type": "Feature",
                        "properties": {
                            "name": `Ligne ${line.name}`,
                            "type": "vertical",
                            "color": config.gridColor,
                            "opacity": config.colorOpacity
                        },
                        "geometry": {
                            "type": "LineString",
                            "coordinates": line.points
                        }
                    };
                    geoJson.features.push(lineFeature);
                });
            }
            
            // Add center points - using HERE Maps specific properties
            if (config.includePoints) {
                gridData.points.forEach(point => {
                    const textOutlineColor = config.needsDarkOutline ? "#000000" : "#FFFFFF";
                    const pointFeature = {
                        "type": "Feature",
                        "properties": {
                            "name": point.name,
                            "icon": "", // Empty icon means no icon will be displayed
                            "label": point.name,
                            "text-color": config.gridColor,
                            "text-outline-color": textOutlineColor,
                            "textSize": config.labelSize
                        },
                        "geometry": {
                            "type": "Point",
                            "coordinates": point.coordinates
                        }
                    };
                    geoJson.features.push(pointFeature);
                });
            }
            
            // Add A1 bottom-left point (always included) using HERE Maps properties
            const displayLat = gridData.a1BottomLeft.coordinates[1].toFixed(8);
            const displayLng = gridData.a1BottomLeft.coordinates[0].toFixed(8);
            const originLabel = `Origine : ${displayLat}, ${displayLng}`;
            const textOutlineColor = config.needsDarkOutline ? "#000000" : "#FFFFFF";
            
            const a1BottomLeftFeature = {
                "type": "Feature",
                "properties": {
                    "name": originLabel,
                    "icon": "", // Empty icon means no icon will be displayed
                    "label": originLabel,
                    "text-color": config.gridColor,
                    "text-outline-color": textOutlineColor,
                    "textSize": config.labelSize
                },
                "geometry": {
                    "type": "Point",
                    "coordinates": gridData.a1BottomLeft.coordinates
                }
            };
            geoJson.features.push(a1BottomLeftFeature);
            
            // Add reference point circle (always included)
            const referenceCircleFeature = {
                "type": "Feature",
                "properties": {
                    "name": "Cercle de référence",
                    "type": "referenceCircle",
                    "color": "#00FFFF",
                    "opacity": 0.2
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": [gridData.referencePoint.circle]
                }
            };
            geoJson.features.push(referenceCircleFeature);
            
            return JSON.stringify(geoJson, null, 2);
        }
        
        function generateGPX(config, gridData) {
            // Convertir couleur hex à format RGB pour OsmAnd
            const hexToRGB = (hex) => {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            };
            
            // Récupérer la date et l'heure actuelles au format ISO
            const currentTime = new Date().toISOString();
            
            // Préparation du contenu GPX
            let gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="Générateur de carroyage CADO"
     xmlns="http://www.topografix.com/GPX/1/1" 
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xmlns:osmand="https://osmand.net"
     xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">
  <metadata>
    <n>${config.gridName}</n>
    <desc>Générateur de carroyage CADO</desc>
    <time>${currentTime}</time>
  </metadata>`;
            
            // Ajouter les points (waypoints)
            if (config.includePoints) {
                gridData.points.forEach(point => {
                    gpx += `
  <wpt lat="${point.coordinates[1]}" lon="${point.coordinates[0]}">
    <n>${point.name}</n>
    <desc>Point central ${point.name}</desc>
    <extensions>
      <osmand:color>${hexToRGB(config.gridColor)}</osmand:color>
      <osmand:icon>special_star</osmand:icon>
      <osmand:background>circle</osmand:background>
    </extensions>
  </wpt>`;
                });
            }
            
            // Ajouter le point d'origine A1
            const displayLat = gridData.a1BottomLeft.coordinates[1];
            const displayLng = gridData.a1BottomLeft.coordinates[0];
            const originLabel = `A1 (${displayLat.toFixed(8)}, ${displayLng.toFixed(8)})`;
            
            gpx += `
  <wpt lat="${displayLat}" lon="${displayLng}">
    <n>${originLabel}</n>
    <desc>Origine du carroyage</desc>
    <extensions>
      <osmand:color>#00FFFF</osmand:color>
      <osmand:icon>special_target</osmand:icon>
      <osmand:background>circle</osmand:background>
    </extensions>
  </wpt>`;
            
            // Ajouter le cercle de référence
            gpx += `
  <trk>
    <n>Cercle de référence</n>
    <extensions>
      <osmand:color>#00FFFF</osmand:color>
      <osmand:width>2</osmand:width>
    </extensions>
    <trkseg>`;
            
            gridData.referencePoint.circle.forEach(point => {
                gpx += `
      <trkpt lat="${point[1]}" lon="${point[0]}"></trkpt>`;
            });
            
            gpx += `
    </trkseg>
  </trk>`;
            
            // Ajouter les lignes horizontales
            if (config.includeGrid) {
                gridData.horizontalLines.forEach(line => {
                    gpx += `
  <trk>
    <n>Ligne ${line.name}</n>
    <extensions>
      <osmand:color>${hexToRGB(config.gridColor)}</osmand:color>
      <osmand:width>2</osmand:width>
    </extensions>
    <trkseg>`;
                    
                    line.points.forEach(point => {
                        gpx += `
      <trkpt lat="${point[1]}" lon="${point[0]}"></trkpt>`;
                    });
                    
                    gpx += `
    </trkseg>
  </trk>`;
                });
                
                // Ajouter les lignes verticales
                gridData.verticalLines.forEach(line => {
                    gpx += `
  <trk>
    <n>Ligne ${line.name}</n>
    <extensions>
      <osmand:color>${hexToRGB(config.gridColor)}</osmand:color>
      <osmand:width>2</osmand:width>
    </extensions>
    <trkseg>`;
                    
                    line.points.forEach(point => {
                        gpx += `
      <trkpt lat="${point[1]}" lon="${point[0]}"></trkpt>`;
                    });
                    
                    gpx += `
    </trkseg>
  </trk>`;
                });
            }
            
            // Fermeture du fichier GPX
            gpx += `
</gpx>`;
            
            return gpx;
        }
        
        function rgbToKmlColor(hexColor, opacity) {
            // Convert hex to RGB
            const r = parseInt(hexColor.slice(1, 3), 16);
            const g = parseInt(hexColor.slice(3, 5), 16);
            const b = parseInt(hexColor.slice(5, 7), 16);
            
            // Convert to KML format (aabbggrr)
            const alpha = Math.floor(opacity * 255).toString(16).padStart(2, '0');
            const blue = b.toString(16).padStart(2, '0');
            const green = g.toString(16).padStart(2, '0');
            const red = r.toString(16).padStart(2, '0');
            
            return alpha + blue + green + red;
        }
        
        function downloadFile(content, filename, contentType) {
            const blob = content instanceof Blob ? content : new Blob([content], {type: contentType});
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            
            setTimeout(function() {
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            }, 0);
        }
        
        function showError(message) {
            const errorDiv = document.getElementById('error-message');
            errorDiv.textContent = message;
            errorDiv.classList.remove('hidden');
        }
        
        function hideError() {
            const errorDiv = document.getElementById('error-message');
            errorDiv.classList.add('hidden');
        }
    </script>
</body>
</html>

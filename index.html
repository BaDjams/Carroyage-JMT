<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Générateur de carroyage CADO V8a</title>
  <style>
    /* Style CSS */
    body {
      font-family: Arial, sans-serif;
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
      box-sizing: border-box;
    }
    h1 {
      font-size: 1.5em;
      text-align: center;
    }
    label {
      display: block;
      margin-bottom: 5px;
      font-size: 0.9em;
    }
    input, select, button, .slider-container {
      width: 100%;
      margin-bottom: 15px;
      padding: 10px;
      font-size: 16px;
      box-sizing: border-box;
    }
    input[type="color"], input[type="range"] {
      padding: 0;
      height: 40px;
    }
    button {
      background-color: #4CAF50;
      color: white;
      border: none;
      cursor: pointer;
      padding: 10px;
    }
    button:hover {
      background-color: #45a049;
    }
    .help-button {
      width: 30px;
      height: 30px;
      margin-left: 10px;
      border-radius: 50%;
      background-color: #4CAF50;
      color: white;
      font-size: 18px;
      font-weight: bold;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      text-decoration: none;
    }
    
   .coord-container {
        display: flex;
        align-items: center;
      }
      
      #coordinates {
        flex: 7; /* 70% de la largeur */
        padding: 8px;
      }
      
      #convertButton {
        flex: 3; /* 30% de la largeur */
        margin-left: 10px;
        padding: 8px 12px;
        background-color: grey; /* Par défaut désactivé */
        color: white;
        border: none;
        cursor: not-allowed; /* Désactivé par défaut */
      }
      
      #convertButton.active {
        background-color: #4CAF50; /* Vert quand actif */
        cursor: pointer;
      }
      
      #convertButton:hover.active {
        background-color: #45a049;
      }



    .help-button:hover {
      background-color: #45a049;
    }

    .button-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      margin-bottom: 15px;
    }
    .button-container button {
      width: auto;
      margin: 5px;
    }
    .slider-value {
      text-align: center;
      margin-top: -10px;
      margin-bottom: 10px;
      font-size: 0.9em;
    }
    @media (max-width: 600px) {
      body {
        padding: 10px;
      }
      h1 {
        font-size: 1.2em;
      }
      input, select, button, .slider-container {
        font-size: 14px;
      }
      .button-container button {
        font-size: 14px;
      }
    }
  </style>
  <script src="geopoint.js"></script>
  <script src="openlocationcode.js"></script>

  <!-- Inclure jszip.js localement pour un fonctionnement hors ligne -->
  <script src="jszip.js"></script>
    <!-- Inclure le fichier images.js AVANT votre script principal -->
  <script src="images.js"></script>
  <script>
   // Conversion de la liste en un dictionnaire pour un accès facile
    const imageBase64Dict = {};
    imageBase64Data.forEach(item => {
      imageBase64Dict[item.name] = item.base64;
    });
    
    const METERS_PER_DEGREE_LAT = 111320;

    function toggleCustomGridOptions() {
      const gridOption = document.getElementById("gridOption").value;
      const defaultGridOptions = document.getElementById("defaultGridOptions");
      const customGridOptions = document.getElementById("customGridOptions");
      const customGridHint = document.getElementById("customGridHint");
    
      if (gridOption === "custom") {
        defaultGridOptions.style.display = "none";
        customGridOptions.style.display = "block";
        customGridHint.style.display = "block";
      } else {
        defaultGridOptions.style.display = "block";
        customGridOptions.style.display = "none";
        customGridHint.style.display = "none";
      }
    }

     function getRequiredImages(points) {
        const requiredImages = {};
      
        // Parcourir les noms des points nécessaires
        points.forEach(point => {
          if (imageBase64Dict[point]) {
            requiredImages[point] = imageBase64Dict[point];
          }
        });
      
        return requiredImages;
      }
    
    function updateSliderValue(sliderId, valueId, unit = '') {
      const slider = document.getElementById(sliderId);
      const valueElement = document.getElementById(valueId);
      valueElement.textContent = slider.value + unit;
    }

    function generateKML(type) {
        const inputField = document.getElementById("gpsDecimal");
        
        // Convertir en degrés décimaux avant génération
      
        const kmlContent = createKMLContent(type, false);
        if (!kmlContent) return;
      
        const filename = getKMLFilename(type);
        downloadFile(kmlContent, filename, 'text/plain');
      }


        // Fonction pour extraire les noms des points depuis le contenu KML
    function extractPointNames(kmlContent) {
      const pointNames = [];
      const regex = /<name>(.*?)<\/name>/g;
      let match;
    
      while ((match = regex.exec(kmlContent)) !== null) {
        pointNames.push(match[1]);
      }
    
      return pointNames;
    }


    async function generateKMZ(type) {
        const inputField = document.getElementById("gpsDecimal");
      
      const kmlDocContent = createKMLContent(type, true);
      if (!kmlDocContent) return;

      // Créer un fichier KMZ en mémoire sans utiliser de fichier ZIP externe
      const zip = new JSZip();

      zip.file("doc.kml", kmlDocContent);

      // Générer les icônes à partir des données base64
       // Extraire les noms des points nécessaires à partir du contenu KML
      const points = extractPointNames(kmlDocContent);
      
      // Récupérer uniquement les images nécessaires
      const requiredImages = getRequiredImages(points);
      
      // Ajouter uniquement les images nécessaires dans le dossier "icons" du KMZ
      const iconsFolder = zip.folder("icons");
      for (const [name, base64] of Object.entries(requiredImages)) {
        iconsFolder.file(`${name}.png`, base64, { base64: true });
      }


      const content = await zip.generateAsync({ type: "blob" });
      const filename = getKMLFilename(type).replace('.kml', '.kmz');
      downloadFile(content, filename, 'application/vnd.google-earth.kmz');
    }

    function createKMLContent(type, isKMZ) {
      const coordinatesInput = document.getElementById("gpsDecimal").value;
      const lengthInput = document.getElementById("length").value;
      const colorInput = document.getElementById("color").value;
      const transparencyInput = document.getElementById("transparency").value;
      const gridOption = document.getElementById("gridOption").value;
      const iconSize = document.getElementById("iconSize").value;
      const deviationInput = document.getElementById("deviation").value;

      if (!validateInputs(coordinatesInput, lengthInput)) return null;

      const [latitude, longitude] = coordinatesInput.split(',').map(coord => parseFloat(coord.trim()));
      const length = parseFloat(lengthInput);
      const referencePoint = document.getElementById("referencePoint").value;

      const transparencyHex = Math.floor((100 - transparencyInput) * 2.55).toString(16).padStart(2, '0');
      const rgbHex = colorInput.slice(1);
      const kmlColor = transparencyHex + rgbHex.slice(4, 6) + rgbHex.slice(2, 4) + rgbHex.slice(0, 2);

      const rowRange = getGridRowRange();
      const colRange = getGridColRange();

      if (!rowRange || !colRange) return null; // Si validation échoue

      let { rowStart, rowEnd } = rowRange;
      let { colStart, colEnd } = colRange;

      const { startingLat, startingLon, rowIndices, colIndices } = calculateStartingPoint(latitude, longitude, length, referencePoint, rowStart, rowEnd, colStart, colEnd);

      let kmlContent = getKMLHeader(kmlColor, isKMZ, iconSize, transparencyHex, rowStart, rowEnd, colStart, colEnd);

      for (let rowIndex of rowIndices) {
        if (rowIndex === 0) continue; // Sauter le zéro pour les lignes
        for (let colIndex of colIndices) {
          if (colIndex === 0) continue; // Sauter le zéro pour les colonnes

          const colLabel = getColumnLabel(colIndex);
          const rowLabel = getRowLabel(rowIndex);

          const coords = getGridCellCoordinates(rowIndex, colIndex, startingLat, startingLon, length, rowIndices, colIndices, referencePoint);

          // Rotation des coins de la grille
          const gridCoords = rotateCoordinates(coords.lat, coords.lon, latitude, longitude, deviationInput);

          // Calcul du centre pour les points avec rotation
          const centerLatOffset = (length / (2 * METERS_PER_DEGREE_LAT)) * ((referencePoint === "topLeft") ? -1 : 1);
          const centerLat = coords.lat + centerLatOffset;
          const centerLon = coords.lon + (length / (2 * (METERS_PER_DEGREE_LAT * Math.cos(coords.lat * (Math.PI / 180)))));
          const pointCoords = rotateCoordinates(centerLat, centerLon, latitude, longitude, deviationInput);

          if ((type === 'grid' || type === 'doc') && type !== 'pointsKMZ') {
            kmlContent += getGridPlacemark(colLabel, rowLabel, gridCoords.lon, gridCoords.lat, length, kmlColor, deviationInput, referencePoint);
          }

          if ((type === 'points' || type === 'doc' || type === 'pointsKMZ')) {
            if (isKMZ) {
              const iconHref = getIconHref(colLabel, rowLabel);
              kmlContent += getKMZPointPlacemark(colLabel, rowLabel, pointCoords.lon, pointCoords.lat, iconHref, true, iconSize, transparencyHex);
            } else {
              kmlContent += getTransparentPointPlacemark(colLabel, rowLabel, pointCoords.lon, pointCoords.lat);
            }
          }
        }
      }

      // Ajouter le cercle blanc aux coordonnées entrées par l'utilisateur
      const lineWidth = 2; // Même épaisseur que les lignes de la grille
      const originPoint = { lat: latitude, lon: longitude };

      kmlContent += getOriginCirclePlacemark(originPoint.lat, originPoint.lon, length, deviationInput, lineWidth);

      kmlContent += `</Document></kml>`;
      return kmlContent;
    }

    function rotateCoordinates(lat, lon, refLat, refLon, angle) {
      // Si aucune déviation n'est spécifiée, retourner les coordonnées originales
      if (angle == 0) return { lat, lon };

      const angleRad = angle * (Math.PI / 180);
      const x = (lon - refLon) * METERS_PER_DEGREE_LAT * Math.cos(refLat * (Math.PI / 180));
      const y = (lat - refLat) * METERS_PER_DEGREE_LAT;
      const rotatedX = x * Math.cos(angleRad) + y * Math.sin(angleRad);
      const rotatedY = -x * Math.sin(angleRad) + y * Math.cos(angleRad);
      const rotatedLon = rotatedX / (METERS_PER_DEGREE_LAT * Math.cos(refLat * (Math.PI / 180))) + refLon;
      const rotatedLat = rotatedY / METERS_PER_DEGREE_LAT + refLat;
      return { lat: rotatedLat, lon: rotatedLon };
    }

    function calculateStartingPoint(lat, lon, length, refPoint, rowStart, rowEnd, colStart, colEnd) {
      let startingLat, startingLon;
      let rowIndices = [], colIndices = [];

      // Générer les indices de lignes et de colonnes en excluant le zéro
      rowIndices = generateIndices(rowStart, rowEnd);
      colIndices = generateIndices(colStart, colEnd);

      const totalRows = rowIndices.length;
      const totalCols = colIndices.length;

      switch (refPoint) {
        case "center":
           {
        const totalHeight = totalRows * length;
        const totalWidth = totalCols * length;

        // Pour "center", on se contente de prendre la moitié du total sans ajustement :
        const deltaLat = (totalHeight / 2) / METERS_PER_DEGREE_LAT;
        const deltaLon = (totalWidth / 2) / (METERS_PER_DEGREE_LAT * Math.cos(lat * (Math.PI / 180)));

        startingLat = lat - deltaLat;
        startingLon = lon - deltaLon;
      }
          break;
        case "topLeft":
          {
            // Trouver les indices de A1
            const a1RowIndex = rowIndices.indexOf(1);
            const a1ColIndex = colIndices.indexOf(1);

            if (a1RowIndex === -1 || a1ColIndex === -1) {
              alert("La case A1 n'existe pas dans le quadrillage spécifié.");
              return null;
            }

            const deltaLat = a1RowIndex * length / METERS_PER_DEGREE_LAT;
            const deltaLon = -a1ColIndex * length / (METERS_PER_DEGREE_LAT * Math.cos(lat * (Math.PI / 180)));

            startingLat = lat + deltaLat;
            startingLon = lon + deltaLon;
          }
          break;
        case "origin":
          {
            // Trouver les indices de A1
            const a1RowIndex = rowIndices.indexOf(1);
            const a1ColIndex = colIndices.indexOf(1);

            if (a1RowIndex === -1 || a1ColIndex === -1) {
              alert("La case A1 n'existe pas dans le quadrillage spécifié.");
              return null;
            }

            const deltaLat = -a1RowIndex * length / METERS_PER_DEGREE_LAT;
            const deltaLon = -a1ColIndex * length / (METERS_PER_DEGREE_LAT * Math.cos(lat * (Math.PI / 180)));

            startingLat = lat + deltaLat;
            startingLon = lon + deltaLon;
          }
          break;
      }

      return { startingLat, startingLon, rowIndices, colIndices };
      console.log("Résultat de calculateStartingPoint:", calculateStartingPoint(latitude, longitude, length, "origin", rowRange.rowStart, rowRange.rowEnd, colRange.colStart, colRange.colEnd));
    }

    function generateIndices(start, end) {
      const indices = [];
      if (start <= end) {
        for (let i = start; i <= end; i++) {
          if (i !== 0) indices.push(i);
        }
      } else {
        for (let i = start; i >= end; i--) {
          if (i !== 0) indices.push(i);
        }
      }
      return indices;
    }

    function validateInputs(coordinates, length) {
      const coords = coordinates.split(',').map(coord => parseFloat(coord.trim()));
      if (coords.length !== 2 || coords.some(isNaN)) {
        alert('Veuillez entrer des coordonnées valides.');
        return false;
      }
      if (isNaN(length) || length <= 0) {
        alert('Veuillez entrer une échelle valide.');
        return false;
      }
      return true;
    }

    function getGridRowRange() {
      if (document.getElementById("gridOption").value === "default") {
        const { start, end } = parseGridOption(document.getElementById("gridType").value).rows;
        return { rowStart: start, rowEnd: end };
      } else {
        const rowStart = parseInt(document.getElementById("customRowStart").value);
        const rowEnd = parseInt(document.getElementById("customRowEnd").value);

        if (isNaN(rowStart) || isNaN(rowEnd)) {
          alert('Veuillez entrer des nombres valides pour les lignes.');
          return null;
        }

        return {
          rowStart: rowStart,
          rowEnd: rowEnd
        };
      }
    }

    function getGridColRange() {
      if (document.getElementById("gridOption").value === "default") {
        const { start, end } = parseGridOption(document.getElementById("gridType").value).cols;
        return { colStart: start, colEnd: end };
      } else {
        const colStartLabel = document.getElementById("customColStart").value.trim();
        const colEndLabel = document.getElementById("customColEnd").value.trim();

        if (!colStartLabel || !colEndLabel) {
          alert('Veuillez entrer des lettres valides pour les colonnes.');
          return null;
        }

        const colStart = columnLabelToIndex(colStartLabel);
        const colEnd = columnLabelToIndex(colEndLabel);

        return {
          colStart: colStart,
          colEnd: colEnd
        };
      }
    }

    function parseGridOption(option) {
      switch (option) {
        case "Z26": return { rows: { start: 1, end: 26 }, cols: { start: 1, end: 26 } };
        case "Z14": return { rows: { start: 1, end: 14 }, cols: { start: 1, end: 26 } };
        case "Q9": return { rows: { start: 1, end: 9 }, cols: { start: 1, end: 17 } };
        default: return { rows: { start: 1, end: 26 }, cols: { start: 1, end: 26 } };
      }
    }

    function getColumnLabel(index) {
      if (index === 0) {
        return ''; // Pas de colonne zéro
      }

      let isNegative = index < 0;
      index = Math.abs(index);

      let label = '';
      while (index > 0) {
        let modulo = (index - 1) % 26;
        label = String.fromCharCode(65 + modulo) + label;
        index = Math.floor((index - 1) / 26);
      }

      return isNegative ? '-' + label : label;
    }

    function columnLabelToIndex(label) {
      let isNegative = false;
      if (label.startsWith('-')) {
        isNegative = true;
        label = label.substring(1);
      }
      label = label.toUpperCase();
      let index = 0;
      for (let i = 0; i < label.length; i++) {
        let charCode = label.charCodeAt(i) - 64; // 'A' is 65
        index = index * 26 + charCode;
      }
      return isNegative ? -index : index;
    }

    function getRowLabel(index) {
      if (index === 0) {
        return ''; // Pas de ligne zéro
      }
      return index.toString();
    }

    function getGridCellCoordinates(rowIndex, colIndex, startingLat, startingLon, length, rowIndices, colIndices, refPoint) {
      // Trouver l'index de la ligne et de la colonne dans les indices
      const rowPosition = rowIndices.indexOf(rowIndex);
      const colPosition = colIndices.indexOf(colIndex);

      let deltaLat, deltaLon;

      if (refPoint === "topLeft") {
        deltaLat = -rowPosition * length / METERS_PER_DEGREE_LAT;
        deltaLon = colPosition * length / (METERS_PER_DEGREE_LAT * Math.cos(startingLat * (Math.PI / 180)));
      } else {
        deltaLat = rowPosition * length / METERS_PER_DEGREE_LAT;
        deltaLon = colPosition * length / (METERS_PER_DEGREE_LAT * Math.cos(startingLat * (Math.PI / 180)));
      }

      const lat = startingLat + deltaLat;
      const lon = startingLon + deltaLon;

      return { lat, lon };
    }

    function getKMLHeader(color, useIcons, iconSize, transparencyHex, rowStart, rowEnd, colStart, colEnd) {
      const gridNameInput = document.getElementById("gridName").value.trim();
      const filename = gridNameInput || 'Carroyage';
      const length = document.getElementById("length").value;
      const scale = `${length}m`;
      const refPoint = document.getElementById("referencePoint").value;
      const deviation = document.getElementById("deviation").value;
      const angle = `${deviation}°`;
      const gridOption = document.getElementById("gridOption").value;
      const rowRange = getGridRowRange();
      const colRange = getGridColRange();
      const gridType = gridOption === "default" 
                       ? document.getElementById("gridType").value 
                       : `Custom_${rowRange.rowStart}_${rowRange.rowEnd}_${getColumnLabel(colRange.colStart)}_${getColumnLabel(colRange.colEnd)}`;

      return `<?xml version="1.0" encoding="UTF-8"?>
              <kml xmlns="http://www.opengis.net/kml/2.2">
                <Document>
                  <name>${filename}_${scale}_${refPoint}_${angle}_${gridType}</name>
                  <description>Généré par le Générateur de carroyage CADO</description>
                  <Style id="gridLineStyle">
                    <LineStyle>
                      <color>${color}</color>
                      <width>2</width>
                    </LineStyle>
                  </Style>
                  <Style id="cado">
                    <LabelStyle>
                      <scale>${useIcons ? '0' : '1'}</scale>
                    </LabelStyle>
                    <IconStyle>
                      <scale>${useIcons ? iconSize : '0.1'}</scale>
                      <Icon>
                        <href>${useIcons ? '' : 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8Xw8AAocB9mP0V70AAAAASUVORK5CYII='}</href>
                      </Icon>
                      <color>${transparencyHex}ffffff</color>
                      <hotSpot x="0.5" y="0.5" xunits="fraction" yunits="fraction"/>
                    </IconStyle>
                  </Style>`;
    }

    function getGridPlacemark(colLabel, rowLabel, lon, lat, length, color, deviation, refPoint) {
      const lonDelta = length / (METERS_PER_DEGREE_LAT * Math.cos(lat * (Math.PI / 180)));
      const latDelta = length / METERS_PER_DEGREE_LAT;

      let topLeft, topRight, bottomRight, bottomLeft;

      if (refPoint === "topLeft") {
        topLeft = rotateCoordinates(lat, lon, lat, lon, deviation);
        topRight = rotateCoordinates(lat, lon + lonDelta, lat, lon, deviation);
        bottomRight = rotateCoordinates(lat - latDelta, lon + lonDelta, lat, lon, deviation);
        bottomLeft = rotateCoordinates(lat - latDelta, lon, lat, lon, deviation);
      } else {
        topLeft = rotateCoordinates(lat, lon, lat, lon, deviation);
        topRight = rotateCoordinates(lat, lon + lonDelta, lat, lon, deviation);
        bottomRight = rotateCoordinates(lat + latDelta, lon + lonDelta, lat, lon, deviation);
        bottomLeft = rotateCoordinates(lat + latDelta, lon, lat, lon, deviation);
      }

      return `<Placemark>
                <name>${colLabel}${rowLabel}</name>
                <Style>
                  <LineStyle>
                    <color>${color}</color>
                    <width>2</width>
                  </LineStyle>
                </Style>
                <LineString>
                  <coordinates>
                    ${topLeft.lon},${topLeft.lat}
                    ${topRight.lon},${topRight.lat}
                    ${bottomRight.lon},${bottomRight.lat}
                    ${bottomLeft.lon},${bottomLeft.lat}
                    ${topLeft.lon},${topLeft.lat}
                  </coordinates>
                </LineString>
              </Placemark>`;
    }

    function getTransparentPointPlacemark(colLabel, rowLabel, lon, lat) {
      // Utiliser une icône transparente intégrée en base64
      const transparentIconBase64 = "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8Xw8AAocB9mP0V70AAAAASUVORK5CYII=";
      return `<Placemark>
                <name>${colLabel}${rowLabel}</name>
                <Style>
                  <IconStyle>
                    <scale>0.1</scale>
                    <Icon>
                      <href>data:image/png;base64,${transparentIconBase64}</href>
                    </Icon>
                  </IconStyle>
                  <LabelStyle>
                    <scale>1</scale>
                  </LabelStyle>
                </Style>
                <Point>
                  <coordinates>${lon},${lat}</coordinates>
                </Point>
              </Placemark>`;
    }

    function getKMZPointPlacemark(colLabel, rowLabel, lon, lat, iconHref, hideLabel, iconSize, transparencyHex) {
      return `<Placemark>
                ${hideLabel ? '' : `<name>${colLabel}${rowLabel}</name>`}
                <Style>
                  <IconStyle>
                    <scale>${iconSize}</scale>
                    <Icon>
                      <href>${iconHref}</href>
                    </Icon>
                    <color>${transparencyHex}ffffff</color>
                  </IconStyle>
                </Style>
                <Point>
                  <coordinates>${lon},${lat}</coordinates>
                </Point>
              </Placemark>`;
    }

    // Fonction pour obtenir le nom de fichier d'icône en utilisant les étiquettes directement
    function getIconHref(colLabel, rowLabel) {
      const iconName = `${colLabel}${rowLabel}.png`;
      return `icons/${iconName}`;
    }
    
    // Fonction pour générer le cercle blanc aux coordonnées entrées par l'utilisateur (contour uniquement)
    function getOriginCirclePlacemark(lat, lon, length, deviation, lineWidth) {
      const circleColor = 'ffffffff'; // Blanc opaque en format KML (aabbggrr)
      const radius = (length / 5) / METERS_PER_DEGREE_LAT; // Rayon en degrés

      const numPoints = 36; // Nombre de points pour approximer le cercle
      const angleStep = 360 / numPoints;

      let coordinates = '';
      for (let i = 0; i <= numPoints; i++) {
        const angleDeg = i * angleStep;
        const angleRad = (angleDeg + parseFloat(deviation)) * (Math.PI / 180);
        const pointLat = lat + (radius * Math.cos(angleRad));
        const pointLon = lon + (radius * Math.sin(angleRad)) / Math.cos(lat * (Math.PI / 180));
        coordinates += `${pointLon},${pointLat} `;
      }

      const circlePlacemark = `
        <Placemark>
          <name>Point de référence</name>
          <Style>
            <LineStyle>
              <color>${circleColor}</color>
              <width>${lineWidth}</width>
            </LineStyle>
            <PolyStyle>
              <fill>0</fill> <!-- Ne pas remplir l'intérieur du polygone -->
            </PolyStyle>
          </Style>
          <Polygon>
            <outerBoundaryIs>
              <LinearRing>
                <coordinates>
                  ${coordinates.trim()}
                </coordinates>
              </LinearRing>
            </outerBoundaryIs>
          </Polygon>
        </Placemark>
      `;

      return circlePlacemark;
    }

function convertFromDecimal() {
    const inputField = document.getElementById("gpsDecimal");
    let inputValue = inputField.value.trim();

    if (!inputValue) {
        alert("Veuillez entrer des coordonnées GPS en décimal.");
        return;
    }

    const coords = inputValue.split(',').map(coord => parseFloat(coord.trim()));

    if (coords.length !== 2 || isNaN(coords[0]) || isNaN(coords[1])) {
        alert("Format invalide. Veuillez entrer des coordonnées sous la forme : latitude, longitude.");
        return;
    }

    // Conversion en DMS
    let geoPoint = new GeoPoint(coords[1], coords[0]);
    document.getElementById("gpsDMS").value = `${geoPoint.getLatDeg()} N, ${geoPoint.getLonDeg()} E`;

    // Conversion en Plus Code
    const plusCode = OpenLocationCode.encode(coords[0], coords[1]);
    document.getElementById("plusCode").value = plusCode;
}

function convertFromDMS() {
    const inputField = document.getElementById("gpsDMS");
    let inputValue = inputField.value.trim();

    if (!inputValue) {
        alert("Veuillez entrer des coordonnées GPS en DMS.");
        return;
    }

    // Vérification du format (exactement une virgule)
    const commaCount = (inputValue.match(/,/g) || []).length;
    if (commaCount !== 1) {
        alert("Format invalide. Veuillez entrer les coordonnées sous la forme : 48°48'30.7\"N, 2°05'41.2\"E");
        return;
    }

    // Convertir en décimal
    let geoPoint = new GeoPoint(inputValue.split(',')[1].trim(), inputValue.split(',')[0].trim());
    if (isNaN(geoPoint.getLatDec()) || isNaN(geoPoint.getLonDec())) {
        alert("Format invalide. Veuillez entrer des coordonnées en DMS correctes.");
        return;
    }

    const latDec = geoPoint.getLatDec().toFixed(8);
    const lonDec = geoPoint.getLonDec().toFixed(8);
    document.getElementById("gpsDecimal").value = `${latDec}, ${lonDec}`;

    // Conversion en Plus Code
    const plusCode = OpenLocationCode.encode(latDec, lonDec);
    document.getElementById("plusCode").value = plusCode;
}


function convertFromPlusCode() {
    const inputField = document.getElementById("plusCode");
    let plusCode = inputField.value.trim();

    if (!plusCode) {
        alert("Veuillez entrer un Plus Code.");
        return;
    }

    if (!OpenLocationCode.isValid(plusCode)) {
        alert("Plus Code invalide.");
        return;
    }

    const decoded = OpenLocationCode.decode(plusCode);
    const lat = decoded.latitudeCenter.toFixed(8);
    const lon = decoded.longitudeCenter.toFixed(8);

    // Mise à jour du champ GPS décimal
    document.getElementById("gpsDecimal").value = `${lat}, ${lon}`;

    // Correction : GeoPoint attend (lon, lat)
    let geoPoint = new GeoPoint(lon, lat);
    document.getElementById("gpsDMS").value = `${geoPoint.getLatDeg()} N, ${geoPoint.getLonDeg()} E`;
}

function generateGeoJSON(type) {
    const inputField = document.getElementById("gpsDecimal");

    if (!inputField.value.trim()) {
        alert("Veuillez entrer des coordonnées GPS valides avant de générer un fichier.");
        return;
    }

    const geojsonContent = createGeoJSONContent(type);
    if (!geojsonContent || geojsonContent.features.length === 0) {
        alert("Erreur : Impossible de générer le fichier GeoJSON. Vérifiez les paramètres.");
        return;
    }

    const filename = getGeoJSONFilename(type);
    const blob = new Blob([JSON.stringify(geojsonContent, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);

    const element = document.createElement("a");
    element.href = url;
    element.download = filename;
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
    URL.revokeObjectURL(url);
}


function createGeoJSONContent(type) {
    const coordinatesInput = document.getElementById("gpsDecimal").value;
    const lengthInput = document.getElementById("length").value;
    const colorInput = document.getElementById("color").value;
    const deviationInput = document.getElementById("deviation").value;

    if (!validateInputs(coordinatesInput, lengthInput)) return null;

    const [latitude, longitude] = coordinatesInput.split(',').map(coord => parseFloat(coord.trim()));
    const length = parseFloat(lengthInput);
    const referencePoint = document.getElementById("referencePoint").value;

    const rowRange = getGridRowRange();
    const colRange = getGridColRange();

    if (!rowRange || !colRange) return null; // Validation échouée

    let { rowStart, rowEnd } = rowRange;
    let { colStart, colEnd } = colRange;

    const { startingLat, startingLon, rowIndices, colIndices } = calculateStartingPoint(latitude, longitude, length, referencePoint, rowStart, rowEnd, colStart, colEnd);

    let features = [];

    for (let rowIndex of rowIndices) {
        if (rowIndex === 0) continue;
        for (let colIndex of colIndices) {
            if (colIndex === 0) continue;

            const colLabel = getColumnLabel(colIndex);
            const rowLabel = getRowLabel(rowIndex);

            const coords = getGridCellCoordinates(rowIndex, colIndex, startingLat, startingLon, length, rowIndices, colIndices, referencePoint);
            const gridCoords = rotateCoordinates(coords.lat, coords.lon, latitude, longitude, deviationInput);

            // Définition des sommets du polygone
            const topLeft = [gridCoords.lon, gridCoords.lat];
            const topRight = [gridCoords.lon + length / (METERS_PER_DEGREE_LAT * Math.cos(gridCoords.lat * (Math.PI / 180))), gridCoords.lat];
            const bottomRight = [gridCoords.lon + length / (METERS_PER_DEGREE_LAT * Math.cos(gridCoords.lat * (Math.PI / 180))), gridCoords.lat - length / METERS_PER_DEGREE_LAT];
            const bottomLeft = [gridCoords.lon, gridCoords.lat - length / METERS_PER_DEGREE_LAT];

            if (type === 'grid' || type === 'both') {
                features.push({
                    "type": "Feature",
                    "geometry": {
                        "type": "Polygon",
                        "coordinates": [[topLeft, topRight, bottomRight, bottomLeft, topLeft]] // Boucle fermée
                    },
                    "properties": {
                        "name": `${colLabel}${rowLabel}`,
                        "color": colorInput
                    }
                });
            }

            if (type === 'points' || type === 'both') {
                const centerLat = coords.lat - (length / (2 * METERS_PER_DEGREE_LAT));
                const centerLon = coords.lon + (length / (2 * (METERS_PER_DEGREE_LAT * Math.cos(coords.lat * (Math.PI / 180)))));
                const pointCoords = rotateCoordinates(centerLat, centerLon, latitude, longitude, deviationInput);

                features.push({
                    "type": "Feature",
                    "geometry": {
                        "type": "Point",
                        "coordinates": [pointCoords.lon, pointCoords.lat]
                    },
                    "properties": {
                        "name": `${colLabel}${rowLabel}`,
                        "title": `${colLabel}${rowLabel}`
                    }
                });
            }
        }
    }

    return {
        "type": "FeatureCollection",
        "features": features
    };
}


function getGeoJSONFilename(type) {
    const gridNameInput = document.getElementById("gridName").value.trim();
    const filename = gridNameInput || 'Carroyage';

    const coordinatesInput = document.getElementById("gpsDecimal").value;
    const [latitude, longitude] = coordinatesInput.split(',').map(coord => parseFloat(coord.trim()));

    const length = parseFloat(document.getElementById("length").value);
    const rowRange = getGridRowRange();
    const colRange = getGridColRange();

    // Vérification des valeurs de ligne/colonne
    if (!rowRange || !colRange) {
        alert("Erreur : Impossible de récupérer les coordonnées de la case A1.");
        return "Erreur.geojson";
    }

    const { startingLat, startingLon } = calculateStartingPoint(latitude, longitude, length, "origin", rowRange.rowStart, rowRange.rowEnd, colRange.colStart, colRange.colEnd);

    // Vérification que les valeurs sont bien des nombres
    if (isNaN(startingLat) || isNaN(startingLon)) {
        alert("Erreur : Les coordonnées de la case A1 ne sont pas valides.");
        return "Erreur.geojson";
    }

    const latOrigin = startingLat.toFixed(8);
    const lonOrigin = startingLon.toFixed(8);

    const deviation = document.getElementById("deviation").value;
    const gridOption = document.getElementById("gridOption").value;
    const gridType = gridOption === "default" 
                     ? document.getElementById("gridType").value 
                     : `Custom_${rowRange.rowStart}_${rowRange.rowEnd}_${getColumnLabel(colRange.colStart)}_${getColumnLabel(colRange.colEnd)}`;

    return `${filename}_${latOrigin}_${lonOrigin}_GeoJSON_${length}m_${deviation}°.geojson`;
}


function getKMLFilename(type) {
  const gridNameInput = document.getElementById("gridName").value.trim();
  const filename = gridNameInput || 'Carroyage';

  const coordinatesInput = document.getElementById("gpsDecimal").value;
  const [latitude, longitude] = coordinatesInput.split(',').map(coord => parseFloat(coord.trim()));

  const length = document.getElementById("length").value;
  const refPoint = document.getElementById("referencePoint").value;
  const rowRange = getGridRowRange();
  const colRange = getGridColRange();

  // Calcul des coordonnées de A1
  const { startingLat, startingLon } = calculateStartingPoint(latitude, longitude, parseFloat(length), "origin", rowRange.rowStart, rowRange.rowEnd, colRange.colStart, colRange.colEnd);

  const latOrigin = startingLat.toFixed(8);
  const lonOrigin = startingLon.toFixed(8);

  const scale = `${length}m`;
  const deviation = document.getElementById("deviation").value;
  const angle = `${deviation}°`;
  const gridOption = document.getElementById("gridOption").value;
  const gridType = gridOption === "default" 
                   ? document.getElementById("gridType").value 
                   : `Custom_${rowRange.rowStart}_${rowRange.rowEnd}_${getColumnLabel(colRange.colStart)}_${getColumnLabel(colRange.colEnd)}`;

  const coordsString = `origine(A1)=${latOrigin}_${lonOrigin}`;

  if (type === 'grid') {
    return `${filename}_${coordsString}_KML-Grille_${scale}_${angle}_${gridType}.kml`;
  } else if (type === 'points') {
    return `${filename}_${coordsString}_KML-Points_${scale}_${angle}_${gridType}.kml`;
  } else if (type === 'pointsKMZ') {
    return `${filename}_${coordsString}_KMZ-Points_${scale}_${angle}_${gridType}.kmz`;
  } else {
    return `${filename}_${coordsString}_KMZ_${scale}_${angle}_${gridType}.kmz`;
  }
}



    function downloadFile(content, filename, mimeType) {
      const element = document.createElement('a');
      element.setAttribute('href', URL.createObjectURL(new Blob([content], {type: mimeType})));
      element.setAttribute('download', filename);
      document.body.appendChild(element);
      element.click();
      document.body.removeChild(element);
    }
  </script>
</head>
<body>
  <h1>Générateur de carroyage CADO  <a href="guide_utilisation.pdf" download class="help-button">?</a></h1>

  <div class="button-container">
    <button onclick="window.open('https://maps.google.com', '_blank')">Ouvrir Google Maps</button>
    <button onclick="window.open('https://www.google.com/mymaps', '_blank')">Ouvrir Google MyMaps</button>
    <button onclick="window.open('https://earth.google.com/web/', '_blank')">Ouvrir Google Earth</button>
  </div>

 <!-- Conversion entre différents formats de coordonnées -->
<label for="gpsDecimal">Coordonnées GPS (décimal) :</label>
<div class="coord-container">
    <input type="text" id="gpsDecimal" placeholder="48.858844, 2.294351" aria-label="Coordonnées GPS en décimal">
    <button onclick="convertFromDecimal()">Convertir</button>
</div>

<label for="gpsDMS">Coordonnées GPS (DMS) :</label>
<div class="coord-container">
    <input type="text" id="gpsDMS" placeholder="48°51'31.8\"N, 2°17'40.3\"E" aria-label="Coordonnées GPS en DMS">
    <button onclick="convertFromDMS()">Convertir</button>
</div>

<label for="plusCode">Plus Code :</label>
<div class="coord-container">
    <input type="text" id="plusCode" placeholder="8FW4VMC5+G6" aria-label="Plus Code">
    <button onclick="convertFromPlusCode()">Convertir</button>
</div>



  <label for="length">Échelle (en mètres) :</label>
  <input type="number" id="length" placeholder="Spécifier l'échelle" aria-label="Échelle" required min="1">
  
  <label for="color">Choisir une couleur :</label>
  <input type="color" id="color" aria-label="Couleur" value="#FFFFFF">
  
  <div class="slider-container">
    <label for="transparency">Transparence :</label>
    <input type="range" id="transparency" min="0" max="100" value="20" aria-label="Transparence" oninput="updateSliderValue('transparency', 'transparencyValue', '%')">
    <div class="slider-value" id="transparencyValue">20%</div>
  </div>

  <label for="gridName">Nom du carroyage :</label>
  <input type="text" id="gridName" placeholder="Nom du carroyage (optionnel)" aria-label="Nom du carroyage">

  <label for="referencePoint">Point de référence :</label>
  <select id="referencePoint" aria-label="Point de référence">
    <option value="center">Milieu du carroyage</option>
    <option value="topLeft">Coin haut gauche</option>
    <option value="origin">Origine (A1)</option>
  </select>
  
  <label for="gridOption">Option de grille :</label>
  <select id="gridOption" aria-label="Option de grille" onchange="toggleCustomGridOptions()">
    <option value="default">Grille par défaut</option>
    <option value="custom">Grille custom</option>
  </select>

  <div id="defaultGridOptions">
    <label for="gridType">Type de grille :</label>
    <select id="gridType" aria-label="Type de grille">
      <option value="Z26">Z26 (26x26)</option>
      <option value="Z14" selected>Z14 (26x14)</option>
      <option value="Q9">Q9 (17x9)</option>
    </select>
  </div>

  <div id="customGridOptions" style="display:none;">
    <label for="customRowStart">Début des lignes (nombres) :</label>
    <input type="number" id="customRowStart" value="1">
    <label for="customRowEnd">Fin des lignes (nombres) :</label>
    <input type="number" id="customRowEnd" value="26">
    <label for="customColStart">Début des colonnes (lettres) :</label>
    <input type="text" id="customColStart" value="A">
    <label for="customColEnd">Fin des colonnes (lettres) :</label>
    <input type="text" id="customColEnd" value="Z">
  </div>
  
  <p id="customGridHint" style="display:none; font-size: 0.9em; color: #888;">
      * Pour une grille personnalisée :
      - Les lignes peuvent aller de -26 à 52.
      - Les colonnes doivent être comprises entre -Z et AZ.
  </p>

  <div class="slider-container">
    <label for="deviation">Déviation (en degrés) :</label>
    <input type="range" id="deviation" min="-180" max="180" value="0" aria-label="Déviation" oninput="updateSliderValue('deviation', 'deviationValue', '°')">
    <div class="slider-value" id="deviationValue">0°</div>
  </div>

  <label for="iconSize">Taille des icônes :</label>
  <input type="range" id="iconSize" min="1" max="5" value="2" step="0.1" aria-label="Taille des icônes" oninput="updateSliderValue('iconSize', 'iconSizeValue')">
  <div class="slider-value" id="iconSizeValue">2</div>

  <!-- Le champ pour le fichier ZIP des icônes a été supprimé, car les données sont chargées depuis data_black.js -->

  <div class="button-container">
    <button onclick="generateKML('grid')">Générer KML Grille</button>
    <button onclick="generateKML('points')">Générer KML Points</button>
    <button onclick="generateKMZ('pointsKMZ')">Générer KMZ Points</button>
    <button onclick="generateKMZ('doc')">Générer KMZ Grille + Points</button>
    <button onclick="generateGeoJSON('grid')">Générer GeoJSON Grille</button>
    <button onclick="generateGeoJSON('points')">Générer GeoJSON Points</button>
    <button onclick="generateGeoJSON('both')">Générer GeoJSON Grille + Points</button>

  </div>
</body>
</html>

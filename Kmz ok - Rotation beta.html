<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Générateur de carroyage CADO</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
      box-sizing: border-box;
    }
    h1 {
      font-size: 1.5em;
      text-align: center;
    }
    label {
      display: block;
      margin-bottom: 5px;
      font-size: 0.9em;
    }
    input, select, button, .slider-container {
      width: 100%;
      margin-bottom: 15px;
      padding: 10px;
      font-size: 16px;
      box-sizing: border-box;
    }
    input[type="color"], input[type="range"] {
      padding: 0;
      height: 40px;
    }
    button {
      background-color: #4CAF50;
      color: white;
      border: none;
      cursor: pointer;
      padding: 10px;
    }
    button:hover {
      background-color: #45a049;
    }
    .button-container {
      display: flex;
      justify-content: center;
      margin-bottom: 15px;
    }
    .button-container button {
      width: auto;
      margin: 0 10px;
    }
    .slider-value {
      text-align: center;
      margin-top: -10px;
      margin-bottom: 10px;
      font-size: 0.9em;
    }
    @media (max-width: 600px) {
      body {
        padding: 10px;
      }
      h1 {
        font-size: 1.2em;
      }
      input, select, button, .slider-container {
        font-size: 14px;
      }
      .button-container button {
        font-size: 14px;
      }
    }
  </style>
  <script src="jszip.js"></script>
  <script>
    const METERS_PER_DEGREE_LAT = 111320;

    function toggleCustomGridOptions() {
      const gridOption = document.getElementById("gridOption").value;
      const defaultGridOptions = document.getElementById("defaultGridOptions");
      const customGridOptions = document.getElementById("customGridOptions");

      if (gridOption === "custom") {
        defaultGridOptions.style.display = "none";
        customGridOptions.style.display = "block";
      } else {
        defaultGridOptions.style.display = "block";
        customGridOptions.style.display = "none";
      }
    }

    function updateSliderValue(sliderId, valueId, unit = '') {
      const slider = document.getElementById(sliderId);
      const valueElement = document.getElementById(valueId);
      valueElement.textContent = slider.value + unit;
    }

    function generateKML(type) {
      const kmlContent = createKMLContent(type, false);
      if (!kmlContent) return;

      const filename = getKMLFilename(type);
      downloadFile(kmlContent, filename, 'text/plain');
    }

    async function generateKMZ() {
      const iconsInput = document.getElementById('iconsFile');
      if (iconsInput.files.length === 0) {
        alert('Veuillez sélectionner le fichier ZIP des icônes.');
        return;
      }

      const iconsData = iconsInput.files[0];
      try {
        const icons = await JSZip.loadAsync(iconsData);

        const kmlDocContent = createKMLContent('doc', true, icons);
        if (!kmlDocContent) return;

        icons.file("doc.kml", kmlDocContent);

        const content = await icons.generateAsync({ type: "blob" });
        const filename = getKMLFilename('kmz').replace('.kml', '.kmz');
        downloadFile(content, filename, 'application/vnd.google-earth.kmz');
      } catch (error) {
        console.error('Error generating KMZ:', error);
      }
    }

    function createKMLContent(type, isKMZ, icons = null) {
      const coordinatesInput = document.getElementById("coordinates").value;
      const lengthInput = document.getElementById("length").value;
      const colorInput = document.getElementById("color").value;
      const transparencyInput = document.getElementById("transparency").value;
      const gridOption = document.getElementById("gridOption").value;
      const iconSize = document.getElementById("iconSize").value;
      const deviationInput = parseFloat(document.getElementById("deviation").value);  // Nouvelle variable pour la déviation

      if (!validateInputs(coordinatesInput, lengthInput)) return null;

      const [latitude, longitude] = coordinatesInput.split(',').map(coord => parseFloat(coord.trim()));
      const length = parseFloat(lengthInput);
      const referencePoint = document.getElementById("referencePoint").value;

      const transparencyHex = Math.floor((100 - transparencyInput) * 2.55).toString(16).padStart(2, '0');
      const rgbHex = colorInput.slice(1);
      const kmlColor = transparencyHex + rgbHex.slice(4, 6) + rgbHex.slice(2, 4) + rgbHex.slice(0, 2);

      const gridRows = getGridRows();
      const gridCols = getGridCols();

      const { startingLat, startingLon } = calculateStartingPoint(latitude, longitude, length, referencePoint, gridRows, gridCols);

      let kmlContent = getKMLHeader(kmlColor, type === 'doc' && isKMZ, iconSize, transparencyHex);

      for (let i = 0; i < gridRows; i++) {
        for (let j = 0; j < gridCols; j++) {
          const row = String.fromCharCode(65 + j);
          const line = referencePoint === "topLeft" ? gridRows - i : i + 1;
          const lat = startingLat + (i * (length / METERS_PER_DEGREE_LAT));
          const lon = startingLon + (j * (length / (METERS_PER_DEGREE_LAT * Math.cos(lat * (Math.PI / 180)))));

          const { rotatedLat, rotatedLon } = applyRotation(lat, lon, latitude, longitude, deviationInput);

          if (type === 'grid' || type === 'doc') {
            kmlContent += getGridPlacemark(row, line, rotatedLon, rotatedLat, length, kmlColor);
          }

          if (type === 'points' || type === 'doc') {
            const centerLat = rotatedLat + (length / (2 * METERS_PER_DEGREE_LAT));
            const centerLon = rotatedLon + (length / (2 * (METERS_PER_DEGREE_LAT * Math.cos(rotatedLat * (Math.PI / 180)))));
            
            if (isKMZ) {
              const iconHref = `icons/${row}${line}.png`;
              kmlContent += getKMZPointPlacemark(row, line, centerLon, centerLat, iconHref, true, iconSize, transparencyHex);
            } else {
              kmlContent += getTransparentPointPlacemark(row, line, centerLon, centerLat);
            }
          }
        }
      }

      kmlContent += `</Document></kml>`;
      return kmlContent;
    }

    function applyRotation(lat, lon, centerLat, centerLon, angleDeg) {
      const angleRad = angleDeg * (Math.PI / 180);
      const latDiff = lat - centerLat;
      const lonDiff = lon - centerLon;

      const rotatedLat = centerLat + (latDiff * Math.cos(angleRad)) - (lonDiff * Math.sin(angleRad));
      const rotatedLon = centerLon + (latDiff * Math.sin(angleRad)) + (lonDiff * Math.cos(angleRad));

      return { rotatedLat, rotatedLon };
    }

    function calculateStartingPoint(lat, lon, length, refPoint, rows, cols) {
      let startingLat, startingLon;

      switch (refPoint) {
        case "center":
          startingLat = lat - ((Math.floor(rows / 2) * length) / METERS_PER_DEGREE_LAT);
          startingLon = lon - ((Math.floor(cols / 2) * length) / (METERS_PER_DEGREE_LAT * Math.cos(lat * (Math.PI / 180))));
          
          if (rows % 2 !== 0) {
            startingLat -= (length / (2 * METERS_PER_DEGREE_LAT));
          }
          if (cols % 2 !== 0) {
            startingLon -= (length / (2 * (METERS_PER_DEGREE_LAT * Math.cos(lat * (Math.PI / 180)))));
          }
          break;
        case "bottomLeft":
          startingLat = lat;
          startingLon = lon;
          break;
        case "topLeft":
          startingLat = lat - (rows * (length / METERS_PER_DEGREE_LAT));
          startingLon = lon;
          break;
      }
      return { startingLat, startingLon };
    }

    function getKMLHeader(color, includeIcons, iconSize, transparency) {
      let header = `<?xml version="1.0" encoding="UTF-8"?>\n<kml xmlns="http://www.opengis.net/kml/2.2">\n<Document>\n`;
      if (includeIcons) {
        header += `<Style id="iconStyle">\n<IconStyle>\n<scale>${iconSize}</scale>\n<Icon>\n<href>icons/{placemark}.png</href>\n</Icon>\n</IconStyle>\n</Style>\n`;
      } else {
        header += `<Style id="transparentStyle">\n<IconStyle>\n<color>${transparency}000000</color>\n<Icon>\n<href>http://maps.google.com/mapfiles/kml/shapes/shaded_dot.png</href>\n</Icon>\n</IconStyle>\n</Style>\n`;
      }
      return header;
    }

    function getGridPlacemark(row, line, lon, lat, length, color) {
      return `<Placemark><name>Carreau ${row}${line}</name>\n<Style><LineStyle><color>${color}</color><width>2</width></LineStyle></Style>\n<Polygon>\n<outerBoundaryIs><LinearRing><coordinates>${lon},${lat},0 ${lon + length},${lat},0 ${lon + length},${lat + length},0 ${lon},${lat + length},0 ${lon},${lat},0</coordinates></LinearRing></outerBoundaryIs>\n</Polygon>\n</Placemark>\n`;
    }

    function getTransparentPointPlacemark(row, line, lon, lat) {
      return `<Placemark><name>Point ${row}${line}</name><styleUrl>#transparentStyle</styleUrl><Point><coordinates>${lon},${lat},0</coordinates></Point></Placemark>\n`;
    }

    function getKMZPointPlacemark(row, line, lon, lat, iconHref, includeIcon, iconSize, transparency) {
      return `<Placemark><name>Point ${row}${line}</name><Style><IconStyle><scale>${iconSize}</scale><Icon><href>${iconHref}</href></Icon></IconStyle><color>${transparency}000000</color></Style><Point><coordinates>${lon},${lat},0</coordinates></Point></Placemark>\n`;
    }

    function downloadFile(content, filename, mimeType) {
      const link = document.createElement("a");
      const file = new Blob([content], { type: mimeType });
      link.href = URL.createObjectURL(file);
      link.download = filename;
      link.click();
      URL.revokeObjectURL(link.href);
    }

    function getKMLFilename(type) {
      const coordinates = document.getElementById("coordinates").value.replace(',', '_');
      const length = document.getElementById("length").value;
      return `${coordinates}_${length}_${type}.kml`;
    }

    function validateInputs(coordinatesInput, lengthInput) {
      if (!coordinatesInput || !coordinatesInput.includes(',')) {
        alert("Veuillez entrer des coordonnées valides.");
        return false;
      }
      if (!lengthInput || isNaN(lengthInput) || lengthInput <= 0) {
        alert("Veuillez entrer une longueur de carreau valide.");
        return false;
      }
      return true;
    }

    function getGridRows() {
      const gridOption = document.getElementById("gridOption").value;
      return gridOption === "default" ? 5 : parseInt(document.getElementById("customRows").value);
    }

    function getGridCols() {
      const gridOption = document.getElementById("gridOption").value;
      return gridOption === "default" ? 5 : parseInt(document.getElementById("customCols").value);
    }
  </script>
</head>
<body>
  <h1>Générateur de carroyage KML/KMZ</h1>
  <label for="coordinates">Coordonnées (latitude,longitude):</label>
  <input type="text" id="coordinates" placeholder="Ex: 48.8584, 2.2945" required>

  <label for="length">Longueur des carreaux (mètres):</label>
  <input type="number" id="length" placeholder="Ex: 100" required>

  <label for="referencePoint">Point de référence:</label>
  <select id="referencePoint">
    <option value="bottomLeft">En bas à gauche</option>
    <option value="center">Centre</option>
    <option value="topLeft">En haut à gauche</option>
  </select>

  <label for="color">Couleur de la grille:</label>
  <input type="color" id="color" value="#ff0000">

  <label for="transparency">Transparence de la grille (%):</label>
  <input type="range" id="transparency" min="0" max="100" value="0" oninput="updateSliderValue('transparency', 'transparencyValue', '%')">
  <div id="transparencyValue" class="slider-value">0%</div>

  <label for="gridOption">Options de grille:</label>
  <select id="gridOption" onchange="toggleCustomGridOptions()">
    <option value="default">Grille par défaut (5x5)</option>
    <option value="custom">Grille personnalisée</option>
  </select>

  <div id="defaultGridOptions"></div>
  <div id="customGridOptions" style="display: none;">
    <label for="customRows">Nombre de lignes:</label>
    <input type="number" id="customRows" placeholder="Ex: 10">
    <label for="customCols">Nombre de colonnes:</label>
    <input type="number" id="customCols" placeholder="Ex: 10">
  </div>

  <label for="deviation">Déviation par rapport au nord (degrés):</label>
  <input type="range" id="deviation" min="-180" max="180" value="0" oninput="updateSliderValue('deviation', 'deviationValue', '°')">
  <div id="deviationValue" class="slider-value">0°</div>

  <label for="iconSize">Taille des icônes (KMZ):</label>
  <input type="range" id="iconSize" min="0.1" max="2" value="1" step="0.1" oninput="updateSliderValue('iconSize', 'iconSizeValue')">
  <div id="iconSizeValue" class="slider-value">1</div>

  <label for="iconsFile">Fichier ZIP des icônes (KMZ):</label>
  <input type="file" id="iconsFile" accept=".zip">

  <div class="button-container">
    <button type="button" onclick="generateKML('grid')">Télécharger KML Grille</button>
    <button type="button" onclick="generateKML('points')">Télécharger KML Points</button>
    <button type="button" onclick="generateKML('doc')">Télécharger KML Grille & Points</button>
    <button type="button" onclick="generateKMZ()">Télécharger KMZ</button>
  </div>
</body>
</html>
